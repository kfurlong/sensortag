<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>module ti.sysbios.family.arm.cc26xx.Power</title>
<meta name="googlebot" content="noindex,nofollow">
<link rel="stylesheet" type="text/css" href="../../../../../src.css"/>
</head>
<body>
<pre class=src>
     1    <span class="comment">/*
</span>     2    <span class="comment"> * Copyright (c) 2012-2015, Texas Instruments Incorporated
</span>     3    <span class="comment"> * All rights reserved.
</span>     4    <span class="comment"> *
</span>     5    <span class="comment"> * Redistribution and use in source and binary forms, with or without
</span>     6    <span class="comment"> * modification, are permitted provided that the following conditions
</span>     7    <span class="comment"> * are met:
</span>     8    <span class="comment"> *
</span>     9    <span class="comment"> * *  Redistributions of source code must retain the above copyright
</span>    10    <span class="comment"> *    notice, this list of conditions and the following disclaimer.
</span>    11    <span class="comment"> *
</span>    12    <span class="comment"> * *  Redistributions in binary form must reproduce the above copyright
</span>    13    <span class="comment"> *    notice, this list of conditions and the following disclaimer in the
</span>    14    <span class="comment"> *    documentation and/or other materials provided with the distribution.
</span>    15    <span class="comment"> *
</span>    16    <span class="comment"> * *  Neither the name of Texas Instruments Incorporated nor the names of
</span>    17    <span class="comment"> *    its contributors may be used to endorse or promote products derived
</span>    18    <span class="comment"> *    from this software without specific prior written permission.
</span>    19    <span class="comment"> *
</span>    20    <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
</span>    21    <span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
</span>    22    <span class="comment"> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
</span>    23    <span class="comment"> * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
</span>    24    <span class="comment"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
</span>    25    <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
</span>    26    <span class="comment"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
</span>    27    <span class="comment"> * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
</span>    28    <span class="comment"> * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
</span>    29    <span class="comment"> * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
</span>    30    <span class="comment"> * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</span>    31    <span class="comment"> */</span>
    32    <span class="comment">/*
</span>    33    <span class="comment"> *  ======== Power.xdc ========
</span>    34    <span class="comment"> *
</span>    35    <span class="comment"> *
</span>    36    <span class="comment"> */</span>
    37    
    38    <span class=key>package</span> ti.sysbios.family.arm.cc26xx;
    39    
    40    import xdc.rov.ViewInfo;
    41    
    42    import xdc.runtime.Assert;
    43    import ti.sysbios.knl.Queue;
    44    import ti.sysbios.knl.Clock;
    45    
    46    <span class="xdoc">/*!
</span>    47    <span class="xdoc"> *  ======== Power ========
</span>    48    <span class="xdoc"> *  CC26xx Power Manager
</span>    49    <span class="xdoc"> *
</span>    50    <span class="xdoc"> *  <b>@p(html)</b>
</span>    51    <span class="xdoc"> *  &lt;h3&gt; Calling Context &lt;/h3&gt;
</span>    52    <span class="xdoc"> *  &lt;table border="1" cellpadding="3"&gt;
</span>    53    <span class="xdoc"> *    &lt;colgroup span="1"&gt;&lt;/colgroup&gt; &lt;colgroup span="5" align="center"&gt;&lt;/colgroup&gt;
</span>    54    <span class="xdoc"> *
</span>    55    <span class="xdoc"> *    &lt;tr&gt;&lt;th&gt; Function                 &lt;/th&gt;&lt;th&gt;  Hwi   &lt;/th&gt;&lt;th&gt;  Swi   &lt;/th&gt;&lt;th&gt;  Task  &lt;/th&gt;&lt;th&gt;  Main  &lt;/th&gt;&lt;th&gt;  Startup  &lt;/th&gt;&lt;/tr&gt;
</span>    56    <span class="xdoc"> *    &lt;!-- --&gt;
</span>    57    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getConstraintInfo}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>    58    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getDependencyCount}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>    59    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getTicksUntilWakeup}  &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>    60    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getTransitionLatency}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>    61    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getTransitionState}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>    62    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getXoscStartupTime}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>    63    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #registerNotify}  &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>    64    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #releaseConstraint}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>    65    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #releaseDependency}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>    66    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #setConstraint}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>    67    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #setDependency}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>    68    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #shutdown}  &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>    69    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #sleep}  &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>    70    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #unregisterNotify}  &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   Y   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>    71    <span class="xdoc"> *    &lt;tr&gt;&lt;td colspan="6"&gt; Definitions: &lt;br /&gt;
</span>    72    <span class="xdoc"> *       &lt;ul&gt;
</span>    73    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Hwi&lt;/b&gt;: API is callable from a Hwi thread &lt;/li&gt;
</span>    74    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Swi&lt;/b&gt;: API is callable from a Swi thread &lt;/li&gt;
</span>    75    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Task&lt;/b&gt;: API is callable from a Task thread &lt;/li&gt;
</span>    76    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Main&lt;/b&gt;: API is callable from main() &lt;/li&gt;
</span>    77    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Startup&lt;/b&gt;: API is callable during any module startup &lt;/li&gt;
</span>    78    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Y&lt;/b&gt;: Yes &lt;/li&gt;
</span>    79    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Y*&lt;/b&gt;: Yes, but see API description for restrictions &lt;/li&gt;
</span>    80    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;N&lt;/b&gt;: No &lt;/li&gt;
</span>    81    <span class="xdoc"> *       &lt;/ul&gt;
</span>    82    <span class="xdoc"> *    &lt;/td&gt;&lt;/tr&gt;
</span>    83    <span class="xdoc"> *
</span>    84    <span class="xdoc"> *  &lt;/table&gt;
</span>    85    <span class="xdoc"> *  <b>@p</b>
</span>    86    <span class="xdoc"> */</span>
    87    
    88    @ModuleStartup            <span class="comment">/* Initialize Power */</span>
    89    @Template(<span class="string">"./Power.xdt"</span>)  <span class="comment">/* Template for contitional initiatialization calls */</span>
    90    
    91    <span class=key>module</span> Power <span class=key>inherits</span> ti.sysbios.interfaces.IPower
    92    {
    93        <span class="xdoc">/*! <b>@_nodoc</b> Idle function prototype */</span>
    94        <span class=key>typedef</span> Void (*FuncPtr)();
    95    
    96        <span class="xdoc">/*!
</span>    97    <span class="xdoc">     *  ======== Constraint ========
</span>    98    <span class="xdoc">     *  Constraints that can be registered with Power
</span>    99    <span class="xdoc">     */</span>
   100        <span class=key>enum</span> Constraint {
   101            SB_VIMS_CACHE_RETAIN      = 0x1, <span class="xdoc">/*! disallow loss of cache context during Power_STANDBY (i.e., retain the cache) */</span>
   102            SD_DISALLOW               = 0x2, <span class="xdoc">/*! disallow transition to SHUTDOWN */</span>
   103            SB_DISALLOW               = 0x4,<span class="xdoc">/*! disallow transition to Power_STANDBY */</span>
   104            IDLE_PD_DISALLOW          = 0x8,<span class="xdoc">/*! disallow power down of the CPU domain during idle time (IDLE_PD) */</span>
   105            NEED_FLASH_IN_IDLE        = 0x10,<span class="xdoc">/*! need to keep Flash powered in IDLE_PD */</span>
   106            NUMCONSTRAINTS = 5
   107        };
   108    
   109        <span class="xdoc">/*!
</span>   110    <span class="xdoc">     *  ======== LatencyType ========
</span>   111    <span class="xdoc">     *  Type of transition latency to query
</span>   112    <span class="xdoc">     */</span>
   113        <span class=key>enum</span> LatencyType {
   114            TOTAL,   <span class="xdoc">/*! the total latency, to enter the sleep state, and to wake and resume */</span>
   115            RESUME   <span class="xdoc">/*! the latency to wake the device and resume execution */</span>
   116        };
   117    
   118        <span class="xdoc">/*!
</span>   119    <span class="xdoc">     *  ======== SleepState ========
</span>   120    <span class="xdoc">     *  Sleep states
</span>   121    <span class="xdoc">     */</span>
   122        <span class=key>enum</span> SleepState {
   123            STANDBY = 0x1   <span class="xdoc">/*! STANDBY state */</span>
   124        };
   125    
   126        <span class="xdoc">/*!
</span>   127    <span class="xdoc">     *  ======== Event ========
</span>   128    <span class="xdoc">     *  Power Event enumerations
</span>   129    <span class="xdoc">     */</span>
   130        <span class=key>enum</span> Event {
   131            ENTERING_STANDBY          = 0x1, <span class="xdoc">/*! device is transitioning into Power_STANDBY */</span>
   132            ENTERING_SHUTDOWN         = 0x2, <span class="xdoc">/*! device is transitioning into SHUTDOWN */</span>
   133            AWAKE_STANDBY             = 0x4, <span class="xdoc">/*! device has awoken from Power_STANDBY, I/O latches are still frozen */</span>
   134            AWAKE_STANDBY_LATE        = 0x8, <span class="xdoc">/*! device has awoken from Power_STANDBY, I/O latches are open again */</span>
   135            XOSC_HF_SWITCHED          = 0x10, <span class="xdoc">/*! the high frequency (HF) crystal oscillator has stabilized, and is now the HF clock source */</span>
   136            NUMEVENTS = 5
   137        };
   138    
   139        <span class="xdoc">/*!
</span>   140    <span class="xdoc">     *  ======== NotifyResponse ========
</span>   141    <span class="xdoc">     *  Return values from a notify function.
</span>   142    <span class="xdoc">     */</span>
   143        <span class=key>enum</span> NotifyResponse {
   144            NOTIFYDONE = 0,<span class="xdoc">/*! success, done processing the notification */</span>
   145            NOTIFYERROR   <span class="xdoc">/*! an error occurred while processing the notification */</span>
   146        };
   147    
   148        <span class="xdoc">/*!
</span>   149    <span class="xdoc">     *  ======== Status ========
</span>   150    <span class="xdoc">     *  Function return codes
</span>   151    <span class="xdoc">     */</span>
   152        <span class=key>enum</span> Status {
   153            SOK = 0,                <span class="xdoc">/*! success */</span>
   154            SOK_STATE_RESTORED = 1, <span class="xdoc">/*! success, context has been restored */</span>
   155            EFAIL = 2,              <span class="xdoc">/*! error, the operation failed */</span>
   156            EINVALIDPOINTER = 3,    <span class="xdoc">/*! error, an invalid pointer was specified */</span>
   157            ECHANGE_NOT_ALLOWED = 4,<span class="xdoc">/*! error, the requested change is not allowed */</span>
   158            ETIMEOUT = 5,           <span class="xdoc">/*! error, a timeout occurred */</span>
   159            EBUSY = 6               <span class="xdoc">/*! error, the operation is not allowed; another transition is not completed yet */</span>
   160        };
   161    
   162        <span class="xdoc">/*!
</span>   163    <span class="xdoc">     *  ======== TransitionState ========
</span>   164    <span class="xdoc">     *  Sleep transition states
</span>   165    <span class="xdoc">     */</span>
   166        <span class=key>enum</span> TransitionState {
   167            ACTIVE = 0x1,        <span class="xdoc">/*! device is active; no transition in progress */</span>
   168            ENTERING_SLEEP = 0x2,<span class="xdoc">/*! device is entering into a sleep state */</span>
   169            EXITING_SLEEP = 0x3, <span class="xdoc">/*! device is exiting a sleep state */</span>
   170            SHUTDOWN = 0x4 <span class="xdoc">/*! device is transitioning to the SHUTDOWN state */</span>
   171        };
   172    
   173        <span class="xdoc">/*! <b>@_nodoc</b> Notification object structure. */</span>
   174        <span class=key>struct</span> NotifyObj {
   175            Queue.Elem link;
   176            UInt32 eventTypes;
   177            Fxn notifyFxn;
   178            UArg clientArg;
   179        };
   180    
   181        <span class=comment>// Asserts</span>
   182    
   183        <span class="xdoc">/*! Assert when Power_releaseConstraint is called too many times */</span>
   184        <span class=key>config</span> Assert.Id A_tooManyCallsReleaseConstraint = {
   185            msg: <span class="string">"A_tooManyCallsReleaseConstraint: Power_releaseConstraint() called too many times for this constraint."</span>
   186        };
   187    
   188        <span class="xdoc">/*! Assert when Power_releaseDependency is called too many times */</span>
   189        <span class=key>config</span> Assert.Id A_tooManyCallsReleaseDependency = {
   190            msg: <span class="string">"A_tooManyCallsReleaseDependency: Power_releaseDependency() called too many times for this resource."</span>
   191        };
   192    
   193        <span class=comment>// configs</span>
   194    
   195        <span class="xdoc">/*!
</span>   196    <span class="xdoc">     *  ======== idle ========
</span>   197    <span class="xdoc">     *  Idle the CPU during idle time?
</span>   198    <span class="xdoc">     *
</span>   199    <span class="xdoc">     *  When this configuration parameter is set to true, the Power module will
</span>   200    <span class="xdoc">     *  insert a power policy function into the list of {<b>@link</b>
</span>   201    <span class="xdoc">     *  ti.sysbios.knl.Idle Idle} loop functions.
</span>   202    <span class="xdoc">     *  When the policy function executes, it will take action to save power
</span>   203    <span class="xdoc">     *  until the next CPU interrupt occurs.  The default power policy will
</span>   204    <span class="xdoc">     *  simply invoke a wait for interrupt (WFI) instruction.
</span>   205    <span class="xdoc">     *
</span>   206    <span class="xdoc">     *  <b>@see</b> #policyFunc
</span>   207    <span class="xdoc">     *  <b>@see</b> #doWFI
</span>   208    <span class="xdoc">     *  <b>@see</b> #standbyPolicy
</span>   209    <span class="xdoc">     */</span>
   210        <span class=key>override</span> <span class=key>config</span> Bool idle = <span class=key>false</span>;
   211    
   212        <span class="xdoc">/*!
</span>   213    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   214    <span class="xdoc">     *  ======== resumeSTANDBY ========
</span>   215    <span class="xdoc">     *  Latency to resume from STANDBY (in microseconds).
</span>   216    <span class="xdoc">     *  NB: this is a temporary value pending further characterization.
</span>   217    <span class="xdoc">     */</span>
   218        <span class=key>metaonly</span> <span class=key>config</span> UInt resumeSTANDBY = 750;
   219    
   220        <span class="xdoc">/*!
</span>   221    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   222    <span class="xdoc">     *  ======== resumeTicksSTANDBY ========
</span>   223    <span class="xdoc">     *  Latency to resume from STANDBY (in units of Clock ticks).
</span>   224    <span class="xdoc">     */</span>
   225        <span class=key>config</span> UInt resumeTicksSTANDBY;
   226    
   227        <span class="xdoc">/*!
</span>   228    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   229    <span class="xdoc">     *  ======== totalSTANDBY ========
</span>   230    <span class="xdoc">     *  Total latency to enter and resume from STANDBY (in microseconds).
</span>   231    <span class="xdoc">     *  NB: this is a temporary value pending further characterization.
</span>   232    <span class="xdoc">     */</span>
   233        <span class=key>metaonly</span> <span class=key>config</span> UInt totalSTANDBY = 1000;
   234    
   235        <span class="xdoc">/*!
</span>   236    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   237    <span class="xdoc">     *  ======== totalTicksSTANDBY ========
</span>   238    <span class="xdoc">     *  Total latency to enter and resume from STANDBY (in units of Clock
</span>   239    <span class="xdoc">     *  ticks).
</span>   240    <span class="xdoc">     */</span>
   241        <span class=key>config</span> UInt totalTicksSTANDBY;
   242    
   243        <span class="xdoc">/*!
</span>   244    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   245    <span class="xdoc">     *  ======== wakeDelaySTANDBY ========
</span>   246    <span class="xdoc">     *  Device initial wakeup latency from STANDBY (in units of microseconds).
</span>   247    <span class="xdoc">     */</span>
   248        <span class=key>config</span> UInt wakeDelaySTANDBY = 130;
   249    
   250        <span class="xdoc">/*!
</span>   251    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   252    <span class="xdoc">     *  ======== initialWaitXOSC_HF ========
</span>   253    <span class="xdoc">     *  Time (in units of usec) to wait to see if XOSC_HF is stable.
</span>   254    <span class="xdoc">     */</span>
   255        <span class=key>config</span> UInt initialWaitXOSC_HF = 50;
   256    
   257        <span class="xdoc">/*!
</span>   258    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   259    <span class="xdoc">     *  ======== retryWaitXOSC_HF ========
</span>   260    <span class="xdoc">     *  Time (in units of usec) to wait when retrying to see if XOSC_HF is
</span>   261    <span class="xdoc">     *   stable.
</span>   262    <span class="xdoc">     */</span>
   263        <span class=key>config</span> UInt retryWaitXOSC_HF = 50;
   264    
   265        <span class="xdoc">/*!
</span>   266    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   267    <span class="xdoc">     *  ======== calibrateRCOSC ========
</span>   268    <span class="xdoc">     *  Enable calibration of RCOSC_LF and RCOSC_HF?
</span>   269    <span class="xdoc">     */</span>
   270        <span class=key>config</span> Bool calibrateRCOSC = <span class=key>true</span>;
   271    
   272        <span class="xdoc">/*!
</span>   273    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   274    <span class="xdoc">     *   Wakeup Clock object's function.  Default is Power_defaultClockFunc.
</span>   275    <span class="xdoc">     */</span>
   276        <span class=key>config</span> Clock.FuncPtr clockFunc = Power.defaultClockFunc;
   277    
   278        <span class="xdoc">/*!
</span>   279    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   280    <span class="xdoc">     *   LF Clock object's function.  Default is Power_lfClockFunc.
</span>   281    <span class="xdoc">     */</span>
   282        <span class=key>config</span> Clock.FuncPtr lfClockFunc = Power.LF_clockFunc;
   283    
   284        <span class="xdoc">/*!
</span>   285    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   286    <span class="xdoc">     *  XOSC_HF Clock object's function.
</span>   287    <span class="xdoc">     */</span>
   288        <span class=key>config</span> Clock.FuncPtr xoscClockFunc = Power.XOSC_HF_clockFunc;
   289    
   290        <span class="xdoc">/*! Policy function.  Default is Power_doWFI. */</span>
   291        <span class=key>metaonly</span> <span class=key>config</span> FuncPtr policyFunc = Power.doWFI;
   292    
   293        <span class="xdoc">/*!
</span>   294    <span class="xdoc">     * <b>@_nodoc</b>
</span>   295    <span class="xdoc">     *  Notify trap function.  Default is Power.defaultNotifyTrapFunc.
</span>   296    <span class="xdoc">     */</span>
   297        <span class=key>config</span> FuncPtr notifyTrapFunc = Power.defaultNotifyTrapFunc;
   298    
   299        <span class=comment>// module functions</span>
   300    
   301        <span class="xdoc">/*!
</span>   302    <span class="xdoc">     *  ======== standbyPolicy ========
</span>   303    <span class="xdoc">     *  A power policy function that will transition the device into the
</span>   304    <span class="xdoc">     *  Power_STANDBY sleep state during CPU idle time.
</span>   305    <span class="xdoc">     *
</span>   306    <span class="xdoc">     *  This is an agressive power policy function that will consider active
</span>   307    <span class="xdoc">     *  constraints, sleep transition latencies, and the next expected wakeup,
</span>   308    <span class="xdoc">     *  and automatically transition the device into the deepest sleep state
</span>   309    <span class="xdoc">     *  possible.
</span>   310    <span class="xdoc">     *
</span>   311    <span class="xdoc">     *  The first goal is to enter Power_STANDBY; if that is not appropriate
</span>   312    <span class="xdoc">     *  given current conditions (e.g., the sleep transition latency is
</span>   313    <span class="xdoc">     *  greater than the time until the next scheduled Clock event), then
</span>   314    <span class="xdoc">     *  the secondary goal is the IDLE_PD state; if that is disallowed (e.g.,
</span>   315    <span class="xdoc">     *  if the Power_IDLE_PD_DISALLOW constraint is declared), then the policy
</span>   316    <span class="xdoc">     *  will fallback and simply invoke wait-for-interrupt, to clock
</span>   317    <span class="xdoc">     *  gate the CPU until the next interrupt.
</span>   318    <span class="xdoc">     *
</span>   319    <span class="xdoc">     *  This policy is enabled and selected via the following application
</span>   320    <span class="xdoc">     *  configuration steps:
</span>   321    <span class="xdoc">     *
</span>   322    <span class="xdoc">     *  <b>@p(code)</b>
</span>   323    <span class="xdoc">     *  Power.idle = true;
</span>   324    <span class="xdoc">     *  Power.policyFunc = Power.standbyPolicy;
</span>   325    <span class="xdoc">     *  <b>@p</b>
</span>   326    <span class="xdoc">     */</span>
   327        Void standbyPolicy();
   328    
   329        <span class="xdoc">/*!
</span>   330    <span class="xdoc">     * <b>@_nodoc</b>
</span>   331    <span class="xdoc">     *  ======== defaultClockFunc ========
</span>   332    <span class="xdoc">     *  Function for the Clock object dedicated for scheduling wakeups.
</span>   333    <span class="xdoc">     */</span>
   334        Void defaultClockFunc(UArg arg);
   335    
   336        <span class="xdoc">/*!
</span>   337    <span class="xdoc">     * <b>@_nodoc</b>
</span>   338    <span class="xdoc">     *  ======== defaultNotifyTrapFunc ========
</span>   339    <span class="xdoc">     *  The default function to be called when a notification client responds
</span>   340    <span class="xdoc">     *  with any value other than Power_NOTIFYDONE.
</span>   341    <span class="xdoc">     *
</span>   342    <span class="xdoc">     *  The default behavior of this function is to spin in an infinite loop.
</span>   343    <span class="xdoc">     */</span>
   344        Void defaultNotifyTrapFunc();
   345    
   346        <span class="xdoc">/*!
</span>   347    <span class="xdoc">     * <b>@_nodoc</b>
</span>   348    <span class="xdoc">     *  ======== LF_clockFunc ========
</span>   349    <span class="xdoc">     *  Function for the Clock object dedicated for disabling the LF clock
</span>   350    <span class="xdoc">     *  qualifiers.
</span>   351    <span class="xdoc">     */</span>
   352        Void LF_clockFunc(UArg arg);
   353    
   354        <span class="xdoc">/*!
</span>   355    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   356    <span class="xdoc">     *  ======== XOSC_HF_xoscClockFunc ========
</span>   357    <span class="xdoc">     *  Function for the Clock object dedicated for XOSC_HF switching.
</span>   358    <span class="xdoc">     */</span>
   359        Void XOSC_HF_clockFunc(UArg arg);
   360    
   361        <span class="xdoc">/*!
</span>   362    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   363    <span class="xdoc">     *  ======== initateCalibration ========
</span>   364    <span class="xdoc">     *  Initiates RCOSC_LF and RCOSC_HF calibration.
</span>   365    <span class="xdoc">     */</span>
   366        Bool initiateCalibration();
   367    
   368        <span class="xdoc">/*!
</span>   369    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   370    <span class="xdoc">     *  ======== startFirstMeasurement ========
</span>   371    <span class="xdoc">     *  Start the first RCOSC calibration measurement
</span>   372    <span class="xdoc">     */</span>
   373        Void startFirstMeasurement();
   374    
   375        <span class="xdoc">/*!
</span>   376    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   377    <span class="xdoc">     *  ======== auxISR ========
</span>   378    <span class="xdoc">     *  ISR for AUX combined interrupt for TDC (for RCOSC calibration)
</span>   379    <span class="xdoc">     */</span>
   380        Void auxISR(UArg arg);
   381    
   382        <span class="xdoc">/*!
</span>   383    <span class="xdoc">     *  ======== getClockHandle ========
</span>   384    <span class="xdoc">     *  Get the handle of the Clock object created for scheduling wakeups.
</span>   385    <span class="xdoc">     */</span>
   386        Clock.Handle getClockHandle();
   387    
   388        <span class="xdoc">/*!
</span>   389    <span class="xdoc">     *  ======== doWFI ========
</span>   390    <span class="xdoc">     *  A power policy function that invokes wait-for-interrupt (WFI)
</span>   391    <span class="xdoc">     *  during idle time.
</span>   392    <span class="xdoc">     *
</span>   393    <span class="xdoc">     *  This is the most basic power policy function, which will invoke
</span>   394    <span class="xdoc">     *  WFI upon entry to the Idle loop.  This is the default policy function
</span>   395    <span class="xdoc">     *  that is invoked when CPU idling is enabled with the {<b>@link</b> #idle idle}
</span>   396    <span class="xdoc">     *  configuration parameter:
</span>   397    <span class="xdoc">     *
</span>   398    <span class="xdoc">     *  <b>@p(code)</b>
</span>   399    <span class="xdoc">     *  Power.idle = true;
</span>   400    <span class="xdoc">     *  <b>@p</b>
</span>   401    <span class="xdoc">     *
</span>   402    <span class="xdoc">     */</span>
   403        Void doWFI();
   404    
   405        <span class="xdoc">/*!
</span>   406    <span class="xdoc">     *  ======== getConstraintInfo ========
</span>   407    <span class="xdoc">     *  Get a bitmask representing the aggregate of constraints that have been
</span>   408    <span class="xdoc">     *  declared.
</span>   409    <span class="xdoc">     *
</span>   410    <span class="xdoc">     *  This function returns a bitmask indicating the constraints that are
</span>   411    <span class="xdoc">     *  currently declared to the Power module (via previous calls to
</span>   412    <span class="xdoc">     *  {<b>@link</b> #setConstraint Power_setConstraint()}).  For each constraint
</span>   413    <span class="xdoc">     *  (of type {<b>@link</b> #Constraint Power_Constraint}) that is currently
</span>   414    <span class="xdoc">     *  declared, the corresponding bit in the bitmask will be set.  For
</span>   415    <span class="xdoc">     *  example, if two clients have declared Power_SB_DISALLOW, and one has
</span>   416    <span class="xdoc">     *  declared Power_SB_VIMS_CACHE_RETAIN, then the returned bitmask
</span>   417    <span class="xdoc">     *  will have the value: Power_SB_DISALLOW | Power_SB_VIMS_CACHE_RETAIN
</span>   418    <span class="xdoc">     *
</span>   419    <span class="xdoc">     *  <b>@b(returns)</b>     A bitmask representing all currently declared
</span>   420    <span class="xdoc">     *                  constraints
</span>   421    <span class="xdoc">     */</span>
   422        UInt32 getConstraintInfo();
   423    
   424        <span class="xdoc">/*!
</span>   425    <span class="xdoc">     *  ======== getDependencyCount ========
</span>   426    <span class="xdoc">     *  Get the count of dependencies that are currently declared upon a
</span>   427    <span class="xdoc">     *  resource.
</span>   428    <span class="xdoc">     *
</span>   429    <span class="xdoc">     *  This function returns the number of dependencies that are currently
</span>   430    <span class="xdoc">     *  declared upon a resource.
</span>   431    <span class="xdoc">     *
</span>   432    <span class="xdoc">     *  <b>@param(resourceID)</b>  The resource identifier, as specified in the
</span>   433    <span class="xdoc">     *                      device-specific header file
</span>   434    <span class="xdoc">     *
</span>   435    <span class="xdoc">     *  <b>@b(returns)</b>     The number of dependencies currently declared upon this
</span>   436    <span class="xdoc">     *                  resourceID
</span>   437    <span class="xdoc">     */</span>
   438        UInt32 getDependencyCount(UInt8 resourceID);
   439    
   440        <span class="xdoc">/*!
</span>   441    <span class="xdoc">     *  ======== getTransitionState ========
</span>   442    <span class="xdoc">     *  Get the current Power module transition state.
</span>   443    <span class="xdoc">     *
</span>   444    <span class="xdoc">     *  <b>@b(returns)</b>     The current transition state, of type
</span>   445    <span class="xdoc">     *                   {<b>@link</b> #TransitionState Power_TransitionState}
</span>   446    <span class="xdoc">     */</span>
   447        TransitionState getTransitionState();
   448    
   449        <span class="xdoc">/*!
</span>   450    <span class="xdoc">     *  ======== getTicksUntilWakeup ========
</span>   451    <span class="xdoc">     *  Get the number of system ticks until the next scheduled wakeup event
</span>   452    <span class="xdoc">     *
</span>   453    <span class="xdoc">     *  <b>@b(returns)</b>     The number of system ticks (i.e.,
</span>   454    <span class="xdoc">     *                  {<b>@link</b> ti.sysbios.knl.Clock Clock} module) ticks
</span>   455    <span class="xdoc">     *                  until the next scheduled wakeup
</span>   456    <span class="xdoc">     */</span>
   457        UInt32 getTicksUntilWakeup();
   458    
   459        <span class="xdoc">/*!
</span>   460    <span class="xdoc">     *  ======== getTransitionLatency ========
</span>   461    <span class="xdoc">     *  Get the minimal transition latency for a sleep state, in units of
</span>   462    <span class="xdoc">     *  system Clock ticks.
</span>   463    <span class="xdoc">     *
</span>   464    <span class="xdoc">     *  Note that the reported latency is the device transition latency for
</span>   465    <span class="xdoc">     *  the specified sleep state.  This latency value does not include any
</span>   466    <span class="xdoc">     *  additional software induced latency, for example, that due to
</span>   467    <span class="xdoc">     *  notifications of the power transition to drivers.
</span>   468    <span class="xdoc">     *
</span>   469    <span class="xdoc">     *  <b>@param(sleepState)</b>  The {<b>@link</b> #SleepState sleepState} whose transition
</span>   470    <span class="xdoc">     *  latency is to be reported (e.g., Power_STANDBY)
</span>   471    <span class="xdoc">     *
</span>   472    <span class="xdoc">     *  <b>@param(type)</b>  The {<b>@link</b> #LatencyType type} of latency to be
</span>   473    <span class="xdoc">     *  reported
</span>   474    <span class="xdoc">     *
</span>   475    <span class="xdoc">     *  <b>@b(returns)</b>     The transition latency, in units of
</span>   476    <span class="xdoc">     *                  {<b>@link</b> ti.sysbios.knl.Clock Clock} ticks.
</span>   477    <span class="xdoc">     */</span>
   478        UInt32 getTransitionLatency(SleepState sleepState, LatencyType type);
   479    
   480        <span class="xdoc">/*!
</span>   481    <span class="xdoc">     *  ======== getXoscStartupTime ========
</span>   482    <span class="xdoc">     *  Get the estimated crystal oscillator startup time, in units of
</span>   483    <span class="xdoc">     *  microseconds.
</span>   484    <span class="xdoc">     *
</span>   485    <span class="xdoc">     *  <b>@param(timeUntilWakeupInMs)</b>  The estimated time until the next wakeup
</span>   486    <span class="xdoc">     *                  event, in units of milliseconds
</span>   487    <span class="xdoc">     *
</span>   488    <span class="xdoc">     *  <b>@b(returns)</b>     The estimated crystal oscillator startup latency, in
</span>   489    <span class="xdoc">     *                  units of microseconds.
</span>   490    <span class="xdoc">     *
</span>   491    <span class="xdoc">     *  <b>@a(Note)</b>  The estimated time until wakeup is in units of milliseconds,
</span>   492    <span class="xdoc">     *            but the the estimate crystal startup time is in microseconds.
</span>   493    <span class="xdoc">     */</span>
   494        UInt32 getXoscStartupTime(UInt32 timeUntilWakeupInMs);
   495    
   496        <span class="xdoc">/*!
</span>   497    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   498    <span class="xdoc">     *  ======== isStableXOSC_HF ========
</span>   499    <span class="xdoc">     *  Check if XOSC_HF has stabilized.
</span>   500    <span class="xdoc">     *
</span>   501    <span class="xdoc">     *  <b>@b(returns)</b>     TRUE if XOSC_HF has stabilized, FALSE if hasn't
</span>   502    <span class="xdoc">     *                  stabilized yet
</span>   503    <span class="xdoc">     */</span>
   504        Bool isStableXOSC_HF();
   505    
   506        <span class="xdoc">/*!
</span>   507    <span class="xdoc">     *  ======== releaseConstraint ========
</span>   508    <span class="xdoc">     *  Release a constraint that was previously declared with {<b>@link</b>
</span>   509    <span class="xdoc">     *  #setConstraint Power_setConstraint()}.
</span>   510    <span class="xdoc">     *
</span>   511    <span class="xdoc">     *  This function releases a constraint that was previously declared with
</span>   512    <span class="xdoc">     *  {<b>@link</b> #setConstraint Power_setConstraint()}.  For example, if a device
</span>   513    <span class="xdoc">     *  driver is starting a transaction and wants to prohibit activation of
</span>   514    <span class="xdoc">     *  the Power_STANDBY sleep mode, it uses {<b>@link</b> #setConstraint
</span>   515    <span class="xdoc">     *  Power_setConstraint} to declare the constraint, before starting
</span>   516    <span class="xdoc">     *  the transaction.  When the transaction completes, the driver calls
</span>   517    <span class="xdoc">     *  this function to release the constraint, and allow the power manager
</span>   518    <span class="xdoc">     *  to once again transition into the Power_STANDBY sleep mode, if
</span>   519    <span class="xdoc">     *  appropriate.
</span>   520    <span class="xdoc">     *
</span>   521    <span class="xdoc">     *  <b>@param(constraint)</b>  The constraint being released, of type {<b>@link</b>
</span>   522    <span class="xdoc">     *                  #Constraint Power_Constraint}
</span>   523    <span class="xdoc">     *
</span>   524    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   525    <span class="xdoc">     *  Power_releaseConstraint() must not be called more than
</span>   526    <span class="xdoc">     *  Power_setConstraint() has been called for the same constraint.  If
</span>   527    <span class="xdoc">     *  asserts are enabled, one will be generated in this case.
</span>   528    <span class="xdoc">     */</span>
   529        Void releaseConstraint(Constraint constraint);
   530    
   531        <span class="xdoc">/*!
</span>   532    <span class="xdoc">     *  ======== releaseDependency ========
</span>   533    <span class="xdoc">     *  Release a dependency that had been previously declared with {<b>@link</b>
</span>   534    <span class="xdoc">     *  #setDependency Power_setDependency()}.
</span>   535    <span class="xdoc">     *
</span>   536    <span class="xdoc">     *  This function is the companion to {<b>@link</b> #setDependency
</span>   537    <span class="xdoc">     *  Power_setDependency()}.  If this release is for the last outstanding
</span>   538    <span class="xdoc">     *  dependency upon the resource, the resource will be de-activated as part
</span>   539    <span class="xdoc">     *  of this function call.
</span>   540    <span class="xdoc">     *
</span>   541    <span class="xdoc">     *  <b>@param(resourceID)</b>  The resource identifier, as specified in the
</span>   542    <span class="xdoc">     *                      device-specific header file
</span>   543    <span class="xdoc">     *
</span>   544    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   545    <span class="xdoc">     *  Power_releaseDependency() must not be called more than
</span>   546    <span class="xdoc">     *  Power_setDependency() has been called for the same resource.  If
</span>   547    <span class="xdoc">     *  asserts are enabled, one will be generated in this case.
</span>   548    <span class="xdoc">     */</span>
   549        Void releaseDependency(UInt8 resourceID);
   550    
   551        <span class="xdoc">/*!
</span>   552    <span class="xdoc">     *  ======== registerNotify ========
</span>   553    <span class="xdoc">     *  Register a function to be called upon a specific power event.
</span>   554    <span class="xdoc">     *
</span>   555    <span class="xdoc">     *  This function registers a function to be called when a
</span>   556    <span class="xdoc">     *  Power event occurs. Registrations and the corresponding notifications
</span>   557    <span class="xdoc">     *  are processed in first-in-first-out (FIFO) order. The function
</span>   558    <span class="xdoc">     *  registered must behave as described below.
</span>   559    <span class="xdoc">     *
</span>   560    <span class="xdoc">     *  The pNotifyObj parameter is a pointer to a pre-allocated, opaque
</span>   561    <span class="xdoc">     *  object that will be used by Power to support the notification.  This
</span>   562    <span class="xdoc">     *  object could be dynamically allocated, or declared as a global object.
</span>   563    <span class="xdoc">     *  Power_registerNotify() will properly initialized the object's fields as
</span>   564    <span class="xdoc">     *  appropriate; the caller just needs to provide a pointer to this
</span>   565    <span class="xdoc">     *  pre-existing object.
</span>   566    <span class="xdoc">     *
</span>   567    <span class="xdoc">     *  The eventType parameter identifies the type of power event for which
</span>   568    <span class="xdoc">     *  the notify function being registered is to be called.  This parameter
</span>   569    <span class="xdoc">     *  is treated as a bitmask, so multiple event types can be registered for
</span>   570    <span class="xdoc">     *  a common function.  The event types are enumerated as {<b>@link</b> #Event
</span>   571    <span class="xdoc">     *  Power_Event}.  For example, to call the specified function when
</span>   572    <span class="xdoc">     *  both the entering standby and the awake from standby events occur,
</span>   573    <span class="xdoc">     *  eventType should be specified as:
</span>   574    <span class="xdoc">     *  (Power_ENTERING_STANDBY | Power_AWAKE_STANDBY)
</span>   575    <span class="xdoc">     *
</span>   576    <span class="xdoc">     *  The clientArg parameter is an arbitrary argument to be passed to the
</span>   577    <span class="xdoc">     *  client upon notification. This argument may allow one notify function
</span>   578    <span class="xdoc">     *  to be used by multiple instances of a driver (that is, the clientArg
</span>   579    <span class="xdoc">     *  can be used to identify the instance of the driver that is being
</span>   580    <span class="xdoc">     *  notified).
</span>   581    <span class="xdoc">     *
</span>   582    <span class="xdoc">     *  The notifyFxn parameter specifies the function to call when the
</span>   583    <span class="xdoc">     *  specified Power event occurs. The notifyFxn must implement
</span>   584    <span class="xdoc">     *  the following signature:
</span>   585    <span class="xdoc">     *
</span>   586    <span class="xdoc">     *      status = notifyFxn(eventType, clientArg);
</span>   587    <span class="xdoc">     *
</span>   588    <span class="xdoc">     *  Where: eventType (type of {<b>@link</b> #Event Power_Event}) is the event
</span>   589    <span class="xdoc">     *  being signalled, and clientArg is the abitrary argument specified
</span>   590    <span class="xdoc">     *  by the client at registration.  Note that multipe types of events
</span>   591    <span class="xdoc">     *  can be specified when registering the notification callback function,
</span>   592    <span class="xdoc">     *  but when the callback function is actually called by Power, only a
</span>   593    <span class="xdoc">     *  single eventType will be specified for the callback (i.e., the current
</span>   594    <span class="xdoc">     *  event).
</span>   595    <span class="xdoc">     *
</span>   596    <span class="xdoc">     *  The client notification function being registered must return one of the
</span>   597    <span class="xdoc">     *  following constants as a status value, of type {<b>@link</b> #NotifyResponse
</span>   598    <span class="xdoc">     *  Power_NotifyResponse}: Power_NOTIFYDONE if the client processed the
</span>   599    <span class="xdoc">     *  notification function successfully, or Power_NOTIFYERROR if the
</span>   600    <span class="xdoc">     *  notification cannot be processed (e.g., if an internal client error
</span>   601    <span class="xdoc">     *  occurs).
</span>   602    <span class="xdoc">     *
</span>   603    <span class="xdoc">     *  <b>@param(pNotifyObj)</b>  The notify object to be used for queuing
</span>   604    <span class="xdoc">     *                      of the notification callback function
</span>   605    <span class="xdoc">     *
</span>   606    <span class="xdoc">     *  <b>@param(eventTypes)</b>  The type or types of {<b>@link</b> #Event Power_Event} to
</span>   607    <span class="xdoc">     *                      be notified of
</span>   608    <span class="xdoc">     *
</span>   609    <span class="xdoc">     *  <b>@param(notifyFxn)</b>  The callback function Power should call to notify
</span>   610    <span class="xdoc">     *                     the client of the event
</span>   611    <span class="xdoc">     *
</span>   612    <span class="xdoc">     *  <b>@param(clientArg)</b>  A client-defined argument to pass with the notifyFxn
</span>   613    <span class="xdoc">     *                     call
</span>   614    <span class="xdoc">     *
</span>   615    <span class="xdoc">     *  <b>@param(arg)</b>        For future use, should be specified as:
</span>   616    <span class="xdoc">     *                     NULL
</span>   617    <span class="xdoc">     *
</span>   618    <span class="xdoc">     *  <b>@b(returns)</b>     Power_SOK if the registration succeeded
</span>   619    <span class="xdoc">     *
</span>   620    <span class="xdoc">     *  <b>@b(returns)</b>     Power_EINVALIDPOINTER if either pNotifyObj or notifyFxn
</span>   621    <span class="xdoc">     *                  were NULL
</span>   622    <span class="xdoc">     *
</span>   623    <span class="xdoc">     */</span>
   624        Status registerNotify(NotifyObj * pNotifyObj, UInt32 eventTypes,
   625            Fxn notifyFxn, UArg clientArg, UArg arg);
   626    
   627        <span class="xdoc">/*!
</span>   628    <span class="xdoc">     *  ======== setConstraint ========
</span>   629    <span class="xdoc">     *  Declare an operational constraint.
</span>   630    <span class="xdoc">     *
</span>   631    <span class="xdoc">     *  Before taking certain actions, Power checks to see if the requested
</span>   632    <span class="xdoc">     *  action would conflict with a client-declared constraint. If the
</span>   633    <span class="xdoc">     *  action does conflict, Power will not proceed with the request.
</span>   634    <span class="xdoc">     *  This is the function that allows clients to declare their constraints
</span>   635    <span class="xdoc">     *  with Power.
</span>   636    <span class="xdoc">     *
</span>   637    <span class="xdoc">     *  It is critical that clients call {<b>@link</b> #releaseConstraint
</span>   638    <span class="xdoc">     *  Power_releaseConstraint()} when operational constraints no longer
</span>   639    <span class="xdoc">     *  exists. Otherwise, Power may be left unnecessarily restricted from
</span>   640    <span class="xdoc">     *  activating power savings.
</span>   641    <span class="xdoc">     *
</span>   642    <span class="xdoc">     *  <b>@param(constraint)</b>  The constraint being declared, of type {<b>@link</b>
</span>   643    <span class="xdoc">     *                  #Constraint Power_Constraint}
</span>   644    <span class="xdoc">     */</span>
   645        Void setConstraint(Constraint constraint);
   646    
   647        <span class="xdoc">/*!
</span>   648    <span class="xdoc">     *  ======== setDependency ========
</span>   649    <span class="xdoc">     *  Declare a dependency upon a power-manageable resource.
</span>   650    <span class="xdoc">     *
</span>   651    <span class="xdoc">     *  This function declares a dependency upon a resource.  If the resource
</span>   652    <span class="xdoc">     *  had been inactive, it will be activated during this function call.
</span>   653    <span class="xdoc">     *
</span>   654    <span class="xdoc">     *  This function is the companion to {<b>@link</b> #releaseDependency
</span>   655    <span class="xdoc">     *  Power_releaseDependency()}.
</span>   656    <span class="xdoc">     *
</span>   657    <span class="xdoc">     *  <b>@param(resourceID)</b>  The resource identifier, as specified in the
</span>   658    <span class="xdoc">     *                      device-specific header file (for example,
</span>   659    <span class="xdoc">     *                      PERIPH_UART0, as defined in PowerCC2650.h)
</span>   660    <span class="xdoc">     *  <b>@a(Note)</b>
</span>   661    <span class="xdoc">     *  When a dependency is declared upon a resource for the first time, the
</span>   662    <span class="xdoc">     *  resource will be activated before the call to Power_setDependency()
</span>   663    <span class="xdoc">     *  returns to the caller.  There is only one exception to this rule:
</span>   664    <span class="xdoc">     *  the XOSC_HF resource for CC26xx.  The latency to startup the crystal
</span>   665    <span class="xdoc">     *  is much longer than that for other resources. To avoid blocking in
</span>   666    <span class="xdoc">     *  Power_setDependency() for this duration, for the XOSC_HF resource
</span>   667    <span class="xdoc">     *  only, Power_setDependency() will return quickly, after initiating the
</span>   668    <span class="xdoc">     *  activation of XOSC_HF.  Once the switchover to the XOSC_HF
</span>   669    <span class="xdoc">     *  happens, notifications will be sent to clients registered for the
</span>   670    <span class="xdoc">     *  Power_XOSC_HF_SWITCHED event.
</span>   671    <span class="xdoc">     *
</span>   672    <span class="xdoc">     *  Power_setDependency() will return a Boolean status to indicate if
</span>   673    <span class="xdoc">     *  the resource is active as the function is initiating a return to the
</span>   674    <span class="xdoc">     *  caller.  For all resources other than XOSC_HF, the return status will
</span>   675    <span class="xdoc">     *  always be TRUE, because the resource will be active before the return
</span>   676    <span class="xdoc">     *  to the caller.  For XOSC_HF, the return status may be TRUE if the
</span>   677    <span class="xdoc">     *  XOSC_HF is already active.  For example, if XOSC_HF was already
</span>   678    <span class="xdoc">     *  activated with an earlier call to Power_setDependency(XOSC_HF).
</span>   679    <span class="xdoc">     *  If the return status is FALSE, this indicates to the caller that
</span>   680    <span class="xdoc">     *  XOSC_HF hadn't been switched by the time the function initiated a
</span>   681    <span class="xdoc">     *  return, and that the caller should wait for the Power_XOSC_HF_SWITCHED
</span>   682    <span class="xdoc">     *  event notification before proceeding to the work that requires XOSC_HF
</span>   683    <span class="xdoc">     *  to be active.
</span>   684    <span class="xdoc">     *
</span>   685    <span class="xdoc">     *  The recommended sequence for a caller to activate XOSC_HF is:
</span>   686    <span class="xdoc">     *
</span>   687    <span class="xdoc">     *
</span>   688    <span class="xdoc">     *      1) Caller registers for a Power_XOSC_HF_SWITCHED notification.
</span>   689    <span class="xdoc">     *         For example, the specified callback function might set a global
</span>   690    <span class="xdoc">     *         flag, which the caller can check to see if the notification
</span>   691    <span class="xdoc">     *         occurred.
</span>   692    <span class="xdoc">     *
</span>   693    <span class="xdoc">     *      2) Caller invokes: status = Power_setDependency(XOSC_HF);
</span>   694    <span class="xdoc">     *
</span>   695    <span class="xdoc">     *
</span>   696    <span class="xdoc">     *      3) Caller checks status to see if XOSC_HF is active yet
</span>   697    <span class="xdoc">     *
</span>   698    <span class="xdoc">     *
</span>   699    <span class="xdoc">     *          - If status is TRUE, XOSC_HF is active, caller should proceed,
</span>   700    <span class="xdoc">     *            and NOT wait for a Power_XOSC_HF_SWITCHED notification
</span>   701    <span class="xdoc">     *
</span>   702    <span class="xdoc">     *          - Else, XOSC_HF wasn't activated yet, caller needs to wait
</span>   703    <span class="xdoc">     *            until the Power_XOSC_HF_SWITCHED event has been signaled.
</span>   704    <span class="xdoc">     *            Note that depending upon timing, the event may have been
</span>   705    <span class="xdoc">     *            signaled between the time the return status was determined
</span>   706    <span class="xdoc">     *            within Power_setDependency() and the time the caller
</span>   707    <span class="xdoc">     *            checks the return status.  The key point is that, when
</span>   708    <span class="xdoc">     *            the return status is FALSE, the Power_XOSC_HF_SWITCHED
</span>   709    <span class="xdoc">     *            notification WILL be sent (once the XOSC_HF is switched),
</span>   710    <span class="xdoc">     *            and the caller should wait for this notification before
</span>   711    <span class="xdoc">     *            proceeding with any work that requires XOSC_HF to be active.
</span>   712    <span class="xdoc">     *
</span>   713    <span class="xdoc">     *  <b>@b(returns)</b>     TRUE if resource is active
</span>   714    <span class="xdoc">     *
</span>   715    <span class="xdoc">     *  <b>@b(returns)</b>     FALSE if resource was not yet active when the function
</span>   716    <span class="xdoc">     *                  return was initiated
</span>   717    <span class="xdoc">     *
</span>   718    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   719    <span class="xdoc">     *  For the XOSC_HF resource (described above), the caller MUST wait for
</span>   720    <span class="xdoc">     *  XOSC_HF activation to complete before calling
</span>   721    <span class="xdoc">     *  Power_releaseDependency(XOSC_HF).
</span>   722    <span class="xdoc">     */</span>
   723        Bool setDependency(UInt8 resourceID);
   724    
   725        <span class="xdoc">/*!
</span>   726    <span class="xdoc">     *  ======== shutdown ========
</span>   727    <span class="xdoc">     *  Put the device into the SHUTDOWN state.
</span>   728    <span class="xdoc">     *
</span>   729    <span class="xdoc">     *  This function will transition the device into the SHUTDOWN state.
</span>   730    <span class="xdoc">     *  Before the actual device transtion is initiated, notifications will
</span>   731    <span class="xdoc">     *  be sent to any clients who've registered for the
</span>   732    <span class="xdoc">     *  Power_ENTERING_SHUTDOWN event (via {<b>@link</b> #registerNotify
</span>   733    <span class="xdoc">     *  Power_registerNotify()}).  Once notifications have been completed, the
</span>   734    <span class="xdoc">     *  device shutdown will commence.
</span>   735    <span class="xdoc">     *
</span>   736    <span class="xdoc">     *  If the device is successfully transitioned to SHUTDOWN, this function
</span>   737    <span class="xdoc">     *  call will never return.  Upon wakeup, the device and application will
</span>   738    <span class="xdoc">     *  be rebooted.  If the transition to SHUTDOWN is not successful, one of
</span>   739    <span class="xdoc">     *  the error codes listed above will be returned.
</span>   740    <span class="xdoc">     *
</span>   741    <span class="xdoc">     *  <b>@param(arg)</b>     Reserved for future use; currently unused
</span>   742    <span class="xdoc">     *
</span>   743    <span class="xdoc">     *  <b>@b(returns)</b>     Power_EBUSY if Power is currently busy with another
</span>   744    <span class="xdoc">     *                  transition
</span>   745    <span class="xdoc">     *
</span>   746    <span class="xdoc">     *  <b>@b(returns)</b>     Power_ECHANGE_NOT_ALLOWED   if SHUTDOWN is disallowed
</span>   747    <span class="xdoc">     *                  due to the Power_SD_DISALLOW constraint having been
</span>   748    <span class="xdoc">     *                  declared
</span>   749    <span class="xdoc">     *
</span>   750    <span class="xdoc">     *  <b>@b(returns)</b>     Power_EFAIL   if a notification error occurred
</span>   751    <span class="xdoc">     *
</span>   752    <span class="xdoc">     *  <b>@a(Note)</b>
</span>   753    <span class="xdoc">     *  This function will not prepare I/O pins for the device
</span>   754    <span class="xdoc">     *  shutdown state.  The application needs to do the appropriate
</span>   755    <span class="xdoc">     *  I/O preparation before calling this API.
</span>   756    <span class="xdoc">     */</span>
   757        Status shutdown(UArg arg);
   758    
   759        <span class="xdoc">/*!
</span>   760    <span class="xdoc">     *  ======== sleep ========
</span>   761    <span class="xdoc">     *  Put the CPU into a sleep state.
</span>   762    <span class="xdoc">     *
</span>   763    <span class="xdoc">     *  This function transitions the device into and out of a sleep state.
</span>   764    <span class="xdoc">     *  The function returns to the caller when the device is awake again.
</span>   765    <span class="xdoc">     *
</span>   766    <span class="xdoc">     *  <b>@param(sleepState)</b>  The sleep state to be entered, of type
</span>   767    <span class="xdoc">     *                      {<b>@link</b> #sleepState Power_sleepState}
</span>   768    <span class="xdoc">     *
</span>   769    <span class="xdoc">     *  <b>@param(arg0)</b>    Reserved for future use; currently unused
</span>   770    <span class="xdoc">     *
</span>   771    <span class="xdoc">     *  <b>@param(arg1)</b>    Reserved for future use; currently unused
</span>   772    <span class="xdoc">     *
</span>   773    <span class="xdoc">     *  <b>@b(returns)</b>     Power_SOK upon success, the device is awake
</span>   774    <span class="xdoc">     *
</span>   775    <span class="xdoc">     *  <b>@b(returns)</b>     Power_EBUSY if Power is currently busy with another
</span>   776    <span class="xdoc">     *                  transition
</span>   777    <span class="xdoc">     *
</span>   778    <span class="xdoc">     *  <b>@b(returns)</b>     Power_EFAIL if a general failure occurred and the
</span>   779    <span class="xdoc">     *                  device was not transitioned into sleep
</span>   780    <span class="xdoc">     *
</span>   781    <span class="xdoc">     *  <b>@a(Note)</b>
</span>   782    <span class="xdoc">     *  Power_sleep() is intended to be called from a Power Policy
</span>   783    <span class="xdoc">     *  implementation function.  This API is not normally called directly
</span>   784    <span class="xdoc">     *  by an application.
</span>   785    <span class="xdoc">     *
</span>   786    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   787    <span class="xdoc">     *  Power_sleep() does not check the constraints that might prohibit a
</span>   788    <span class="xdoc">     *  sleep transition.  The caller of Power_sleep() must validate the
</span>   789    <span class="xdoc">     *  transition versus active constraints, prior to calling Power_sleep().
</span>   790    <span class="xdoc">     */</span>
   791        Status sleep(SleepState sleepState, UArg arg0, UArg arg1);
   792    
   793        <span class="xdoc">/*!
</span>   794    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   795    <span class="xdoc">     *  ======== switchXOSC_HF ========
</span>   796    <span class="xdoc">     *  Switch to enable XOSC_HF.
</span>   797    <span class="xdoc">     */</span>
   798        Void switchXOSC_HF();
   799    
   800        <span class="xdoc">/*!
</span>   801    <span class="xdoc">     *  ======== unregisterNotify ========
</span>   802    <span class="xdoc">     *  Unregister for Power event notifications.
</span>   803    <span class="xdoc">     *
</span>   804    <span class="xdoc">     *  This function unregisters for event notifications that were previously
</span>   805    <span class="xdoc">     *  registered with {<b>@link</b> #registerNotify Power_registerNotify()}.
</span>   806    <span class="xdoc">     *
</span>   807    <span class="xdoc">     *  <b>@param(pNotifyObj)</b>  The notification object that was previously
</span>   808    <span class="xdoc">     *                      used with {<b>@link</b> #registerNotify
</span>   809    <span class="xdoc">     *                      Power_registerNotify()} to register for
</span>   810    <span class="xdoc">     *                      event notifications
</span>   811    <span class="xdoc">     */</span>
   812        Void unregisterNotify(NotifyObj * pNotifyObj);
   813    
   814    
   815        <span class="xdoc">/*! <b>@_nodoc</b> */</span>
   816        @XmlDtd
   817        <span class=key>metaonly</span> <span class=key>struct</span> ModuleView {
   818            String    ConstraintsMask;
   819        };
   820    
   821        <span class="xdoc">/*! <b>@_nodoc</b> */</span>
   822        @Facet
   823        <span class=key>metaonly</span> <span class=key>config</span> ViewInfo.Instance rovViewInfo =
   824            ViewInfo.create({
   825                viewMap: [
   826                [
   827                    <span class="string">'Module'</span>,
   828                    {
   829                        type: ViewInfo.MODULE,
   830                        viewInitFxn: <span class="string">'viewInitModule'</span>,
   831                        structName: <span class="string">'ModuleView'</span>
   832                    }
   833                ],
   834                ]
   835            });
   836    
   837        <span class="xdoc">/*!
</span>   838    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   839    <span class="xdoc">     *  ======== idleCPU ========
</span>   840    <span class="xdoc">     *  Function used to automatically idle the CPU in the Idle loop.
</span>   841    <span class="xdoc">     *
</span>   842    <span class="xdoc">     *  When the 'idle' configuration parameter is set, this function will
</span>   843    <span class="xdoc">     *  be added to the list of Idle loop functions.  When called from the
</span>   844    <span class="xdoc">     *  Idle loop, it will invoke the wait for interrupt (WFI) instruction,
</span>   845    <span class="xdoc">     *  to idle the CPU until the next interrupt occurs.
</span>   846    <span class="xdoc">     */</span>
   847        Void idleCPU();
   848    
   849    <span class=key>internal</span>:
   850    
   851        <span class="comment">/*
</span>   852    <span class="comment">     *  ======== notify ========
</span>   853    <span class="comment">     */</span>
   854        Status notify(Event eventType);
   855    
   856        <span class="comment">/*
</span>   857    <span class="comment">     *  ======== serviceNotifyQ ========
</span>   858    <span class="comment">     */</span>
   859        NotifyResponse serviceNotifyQ(Event eventType);
   860    
   861        <span class="comment">/*
</span>   862    <span class="comment">     *  ======== Module_State ========
</span>   863    <span class="comment">     */</span>
   864        <span class=key>struct</span> Module_State {
   865            UInt32 constraintsMask;
   866            Queue.Object notifyQ;       <span class="comment">/* event notification queue */</span>
   867            Clock.Object clockObj;      <span class="comment">/* Clock object for scheduling wakeups */</span>
   868            Clock.Object xoscClockObj;  <span class="comment">/* Clock object for XOSC_HF switching */</span>
   869            Clock.Object lfClockObj;    <span class="comment">/* Clock object for LF clock check */</span>
   870            TransitionState state;
   871            Bool xoscPending;           <span class="comment">/* is XOSC_HF activation in progress? */</span>
   872        }
   873    }
</pre>
</body></html>
