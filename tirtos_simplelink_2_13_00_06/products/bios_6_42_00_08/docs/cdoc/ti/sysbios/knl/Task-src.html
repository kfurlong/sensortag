<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>module ti.sysbios.knl.Task</title>
<meta name="googlebot" content="noindex,nofollow">
<link rel="stylesheet" type="text/css" href="../../../src.css"/>
</head>
<body>
<pre class=src>
     1    <span class="comment">/*
</span>     2    <span class="comment"> * Copyright (c) 2015, Texas Instruments Incorporated
</span>     3    <span class="comment"> * All rights reserved.
</span>     4    <span class="comment"> *
</span>     5    <span class="comment"> * Redistribution and use in source and binary forms, with or without
</span>     6    <span class="comment"> * modification, are permitted provided that the following conditions
</span>     7    <span class="comment"> * are met:
</span>     8    <span class="comment"> *
</span>     9    <span class="comment"> * *  Redistributions of source code must retain the above copyright
</span>    10    <span class="comment"> *    notice, this list of conditions and the following disclaimer.
</span>    11    <span class="comment"> *
</span>    12    <span class="comment"> * *  Redistributions in binary form must reproduce the above copyright
</span>    13    <span class="comment"> *    notice, this list of conditions and the following disclaimer in the
</span>    14    <span class="comment"> *    documentation and/or other materials provided with the distribution.
</span>    15    <span class="comment"> *
</span>    16    <span class="comment"> * *  Neither the name of Texas Instruments Incorporated nor the names of
</span>    17    <span class="comment"> *    its contributors may be used to endorse or promote products derived
</span>    18    <span class="comment"> *    from this software without specific prior written permission.
</span>    19    <span class="comment"> *
</span>    20    <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
</span>    21    <span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
</span>    22    <span class="comment"> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
</span>    23    <span class="comment"> * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
</span>    24    <span class="comment"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
</span>    25    <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
</span>    26    <span class="comment"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
</span>    27    <span class="comment"> * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
</span>    28    <span class="comment"> * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
</span>    29    <span class="comment"> * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
</span>    30    <span class="comment"> * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</span>    31    <span class="comment"> */</span>
    32    <span class="comment">/*
</span>    33    <span class="comment"> *  ======== Task.xdc ========
</span>    34    <span class="comment"> *
</span>    35    <span class="comment"> */</span>
    36    
    37    <span class=key>package</span> ti.sysbios.knl;
    38    
    39    import xdc.rov.ViewInfo;
    40    
    41    import xdc.runtime.Error;
    42    import xdc.runtime.Assert;
    43    import xdc.runtime.Diags;
    44    import xdc.runtime.Log;
    45    import xdc.runtime.IHeap;
    46    
    47    import ti.sysbios.knl.Queue;
    48    
    49    <span class="xdoc">/*!
</span>    50    <span class="xdoc"> *  ======== Task ========
</span>    51    <span class="xdoc"> *  Task Manager.
</span>    52    <span class="xdoc"> *
</span>    53    <span class="xdoc"> *  The Task module makes available a set of functions that manipulate task
</span>    54    <span class="xdoc"> *  objects accessed through pointers of type {<b>@link</b> #Handle}. Tasks represent
</span>    55    <span class="xdoc"> *  independent threads of control that conceptually execute functions in
</span>    56    <span class="xdoc"> *  parallel within a single C program; in reality, concurrency is achieved
</span>    57    <span class="xdoc"> *  by switching the processor from one task to another.
</span>    58    <span class="xdoc"> *
</span>    59    <span class="xdoc"> *  When you create a task, it is provided with its own run-time stack,
</span>    60    <span class="xdoc"> *  used for storing local variables as well as for further nesting of
</span>    61    <span class="xdoc"> *  function calls. Each stack must be large enough to handle normal
</span>    62    <span class="xdoc"> *  subroutine calls and one task preemption context.
</span>    63    <span class="xdoc"> *  A task preemption context is the context that gets saved when one task
</span>    64    <span class="xdoc"> *  preempts another as a result of an interrupt thread readying
</span>    65    <span class="xdoc"> *  a higher-priority task.
</span>    66    <span class="xdoc"> *
</span>    67    <span class="xdoc"> *  All tasks executing within a single program share a common set of
</span>    68    <span class="xdoc"> *  global variables, accessed according to the standard rules of scope
</span>    69    <span class="xdoc"> *  defined for C functions.
</span>    70    <span class="xdoc"> *
</span>    71    <span class="xdoc"> *  Each task is in one of five modes of execution at any point in time:
</span>    72    <span class="xdoc"> *  running, ready, blocked, terminated, or inactive. By design, there is
</span>    73    <span class="xdoc"> *  always one
</span>    74    <span class="xdoc"> *  (and only one) task currently running, even if it is only the idle task
</span>    75    <span class="xdoc"> *  managed internally by Task. The current task can be suspended from
</span>    76    <span class="xdoc"> *  execution by calling certain Task functions, as well as functions
</span>    77    <span class="xdoc"> *  provided by other modules like the Semaphore or Event Modules.
</span>    78    <span class="xdoc"> *  The current task
</span>    79    <span class="xdoc"> *  can also terminate its own execution. In either case, the processor
</span>    80    <span class="xdoc"> *  is switched to the highest priority task that is ready to run.
</span>    81    <span class="xdoc"> *
</span>    82    <span class="xdoc"> *  You can assign numeric priorities to tasks. Tasks are
</span>    83    <span class="xdoc"> *  readied for execution in strict priority order; tasks of the same
</span>    84    <span class="xdoc"> *  priority are scheduled on a first-come, first-served basis.
</span>    85    <span class="xdoc"> *  The priority of the currently running task is never lower
</span>    86    <span class="xdoc"> *  than the priority of any ready task. Conversely, the running task
</span>    87    <span class="xdoc"> *  is preempted and re-scheduled for execution whenever there exists
</span>    88    <span class="xdoc"> *  some ready task of higher priority.
</span>    89    <span class="xdoc"> *
</span>    90    <span class="xdoc"> *  <b>@a(Task Deletion)</b>
</span>    91    <span class="xdoc"> *
</span>    92    <span class="xdoc"> *  Any dynamically created task that is not in the Task_Mode_RUNNING
</span>    93    <span class="xdoc"> *  state (ie not the currently running task) can be deleted using the
</span>    94    <span class="xdoc"> *  {<b>@link</b> #delete} API.
</span>    95    <span class="xdoc"> *
</span>    96    <span class="xdoc"> *  Task_delete() removes the task from all internal queues and calls
</span>    97    <span class="xdoc"> *  Memory_free() is used to free the task object and its stack.
</span>    98    <span class="xdoc"> *  Memory_free() must acquire a lock to the memory before proceeding.
</span>    99    <span class="xdoc"> *  If another task already holds a lock to the memory, then the thread
</span>   100    <span class="xdoc"> *  performing the delete will be blocked until the memory is unlocked.
</span>   101    <span class="xdoc"> *
</span>   102    <span class="xdoc"> *  Note:
</span>   103    <span class="xdoc"> *  Task_delete() should be called with extreme care.
</span>   104    <span class="xdoc"> *  As mentioned above, the scope of Task_delete() is limited to
</span>   105    <span class="xdoc"> *  freeing the Task object itself, freeing the task's stack memory
</span>   106    <span class="xdoc"> *  if it was allocated at create time, and removing the task from
</span>   107    <span class="xdoc"> *  any SYS/BIOS-internal state structures.
</span>   108    <span class="xdoc"> *
</span>   109    <span class="xdoc"> *  SYS/BIOS does not keep track of any resources the task may have
</span>   110    <span class="xdoc"> *  acquired or used during its lifetime.
</span>   111    <span class="xdoc"> *
</span>   112    <span class="xdoc"> *  It is the application's responsibility to guarantee the integrity
</span>   113    <span class="xdoc"> *  of a task's partnerships prior to deleting that task.
</span>   114    <span class="xdoc"> *
</span>   115    <span class="xdoc"> *  For example, if a task has obtained exclusive access to a resource,
</span>   116    <span class="xdoc"> *  deleting that task will make the resource forever unavailable.
</span>   117    <span class="xdoc"> *
</span>   118    <span class="xdoc"> *  Task_delete() sets the referenced task handle to NULL. Any subsequent
</span>   119    <span class="xdoc"> *  call to a Task instance API using that null task handle will behave
</span>   120    <span class="xdoc"> *  unpredictably and will usually result in an application crash.
</span>   121    <span class="xdoc"> *
</span>   122    <span class="xdoc"> *  Assuming a task completely cleans up after itself prior to calling
</span>   123    <span class="xdoc"> *  Task_exit() (or falling through the the bottom of the task
</span>   124    <span class="xdoc"> *  function), it is then safest to use Task_delete() only when a task
</span>   125    <span class="xdoc"> *  is in the 'Task_Mode_TERMINATED' state.
</span>   126    <span class="xdoc"> *
</span>   127    <span class="xdoc"> *  Delete hooks:
</span>   128    <span class="xdoc"> *  You can specify application-wide Delete hook functions that
</span>   129    <span class="xdoc"> *  run whenever a task is deleted. See the discussion of Hook Functions
</span>   130    <span class="xdoc"> *  below for details.
</span>   131    <span class="xdoc"> *
</span>   132    <span class="xdoc"> *  Task_delete() constraints:
</span>   133    <span class="xdoc"> *  <b>@p(blist)</b>
</span>   134    <span class="xdoc"> *  -The task cannot be the currently executing task (Task_self()).
</span>   135    <span class="xdoc"> *  -Task_delete cannot be called from a Swi or Hwi.
</span>   136    <span class="xdoc"> *  -No check is performed to prevent Task_delete from being used on a
</span>   137    <span class="xdoc"> *  statically-created object. If a program attempts to delete a task object
</span>   138    <span class="xdoc"> *  that was created statically, the Memory_free() call will result in an
</span>   139    <span class="xdoc"> *  assertion failure in its corresponding Heap manager, causing the
</span>   140    <span class="xdoc"> *  application to exit.
</span>   141    <span class="xdoc"> *  <b>@p</b>
</span>   142    <span class="xdoc"> *
</span>   143    <span class="xdoc"> *  <b>@a(Stack Alignment)</b>
</span>   144    <span class="xdoc"> *
</span>   145    <span class="xdoc"> *  Stack size parameters for both static and dynamic tasks are rounded
</span>   146    <span class="xdoc"> *  up to the nearest integer multiple of a target-specific alignment
</span>   147    <span class="xdoc"> *  requirement.
</span>   148    <span class="xdoc"> *
</span>   149    <span class="xdoc"> *  In the case of Task's which are created with a user-provided stack,
</span>   150    <span class="xdoc"> *  both the base address and the stackSize are aligned. The base address
</span>   151    <span class="xdoc"> *  is increased to the nearest aligned address. The stack size is decreased
</span>   152    <span class="xdoc"> *  accordingly and then rounded down to the nearest integer multiple of the
</span>   153    <span class="xdoc"> *  target-specific required alignment.
</span>   154    <span class="xdoc"> *
</span>   155    <span class="xdoc"> *  <b>@p(html)</b>
</span>   156    <span class="xdoc"> *  &lt;a name="hookfunc"&gt;&lt;/a&gt;
</span>   157    <span class="xdoc"> *  <b>@p</b>
</span>   158    <span class="xdoc"> *
</span>   159    <span class="xdoc"> *  <b>@a(Hook Functions)</b>
</span>   160    <span class="xdoc"> *
</span>   161    <span class="xdoc"> *  Sets of hook functions can be specified for the Task module.  Each
</span>   162    <span class="xdoc"> *  set can contains these hook functions:
</span>   163    <span class="xdoc"> *  <b>@p(blist)</b>
</span>   164    <span class="xdoc"> *  -Register: A function called before any statically created tasks
</span>   165    <span class="xdoc"> *      are initialized at runtime.  The register hook is called at boot time
</span>   166    <span class="xdoc"> *      before main() and before interrupts are enabled.
</span>   167    <span class="xdoc"> *  -Create: A function that is called when a task is created.
</span>   168    <span class="xdoc"> *      This includes tasks that are created statically and those
</span>   169    <span class="xdoc"> *      created dynamically using {<b>@link</b> #create} or {<b>@link</b> #construct}.
</span>   170    <span class="xdoc"> *      The create hook is called outside of a Task_disable/enable block and
</span>   171    <span class="xdoc"> *   before the task has been added to the ready list.
</span>   172    <span class="xdoc"> *  -Ready: A function that is called when a task becomes ready to run.
</span>   173    <span class="xdoc"> *   The ready hook is called from within a Task_disable/enable block with
</span>   174    <span class="xdoc"> *   interrupts enabled.
</span>   175    <span class="xdoc"> *  -Switch: A function that is called just before a task switch
</span>   176    <span class="xdoc"> *      occurs. The 'prev' and 'next' task handles are passed to the Switch
</span>   177    <span class="xdoc"> *      hook. 'prev' is set to NULL for the initial task switch that occurs
</span>   178    <span class="xdoc"> *      during SYS/BIOS startup.  The Switch hook is called from within a
</span>   179    <span class="xdoc"> *      Task_disable/enable block with interrupts enabled.
</span>   180    <span class="xdoc"> *  -Exit:      A function that is called when a task exits using
</span>   181    <span class="xdoc"> *      {<b>@link</b> #exit}.  The exit hook is passed the handle of the exiting
</span>   182    <span class="xdoc"> *      task.  The exit hook is called outside of a Task_disable/enable block
</span>   183    <span class="xdoc"> *      and before the task has been removed from the kernel lists.
</span>   184    <span class="xdoc"> *  -Delete: A function that is called when any task is deleted at
</span>   185    <span class="xdoc"> *      run-time with {<b>@link</b> #delete}.  The delete hook is called outside
</span>   186    <span class="xdoc"> *      of a Task_disable/enable block.
</span>   187    <span class="xdoc"> *  <b>@p</b>
</span>   188    <span class="xdoc"> *  Hook functions can only be configured statically.
</span>   189    <span class="xdoc"> *
</span>   190    <span class="xdoc"> *  If you define more than one set of hook functions, all the functions
</span>   191    <span class="xdoc"> *  of a particular type will be run when a Swi triggers that type of
</span>   192    <span class="xdoc"> *  hook.
</span>   193    <span class="xdoc"> *
</span>   194    <span class="xdoc"> *  <b>@p(html)</b>
</span>   195    <span class="xdoc"> *  &lt;B&gt;Register Function&lt;/B&gt;
</span>   196    <span class="xdoc"> *  <b>@p</b>
</span>   197    <span class="xdoc"> *
</span>   198    <span class="xdoc"> *  The Register function is provided to allow a hook set to store its
</span>   199    <span class="xdoc"> *  hookset ID.  This id can be passed to {<b>@link</b> #setHookContext} and
</span>   200    <span class="xdoc"> *  {<b>@link</b> #getHookContext} to set or get hookset-specific context.  The
</span>   201    <span class="xdoc"> *  Register function must be specified if the hook implementation
</span>   202    <span class="xdoc"> *  needs to use {<b>@link</b> #setHookContext} or {<b>@link</b> #getHookContext}.
</span>   203    <span class="xdoc"> *  The registerFxn hook function is called during system initialization
</span>   204    <span class="xdoc"> *  before interrupts have been enabled.
</span>   205    <span class="xdoc"> *
</span>   206    <span class="xdoc"> *  <b>@p(code)</b>
</span>   207    <span class="xdoc"> *  Void myRegisterFxn(Int id);
</span>   208    <span class="xdoc"> *  <b>@p</b>
</span>   209    <span class="xdoc"> *
</span>   210    <span class="xdoc"> *  <b>@p(html)</b>
</span>   211    <span class="xdoc"> *  &lt;B&gt;Create and Delete Functions&lt;/B&gt;
</span>   212    <span class="xdoc"> *  <b>@p</b>
</span>   213    <span class="xdoc"> *
</span>   214    <span class="xdoc"> *  The create and delete functions are called whenever a Task is created
</span>   215    <span class="xdoc"> *  or deleted.  They are called with interrupts enabled (unless called
</span>   216    <span class="xdoc"> *  at boot time or from main()).
</span>   217    <span class="xdoc"> *
</span>   218    <span class="xdoc"> *  <b>@p(code)</b>
</span>   219    <span class="xdoc"> *  Void myCreateFxn(Task_Handle task, Error_Block *eb);
</span>   220    <span class="xdoc"> *  <b>@p</b>
</span>   221    <span class="xdoc"> *
</span>   222    <span class="xdoc"> *  <b>@p(code)</b>
</span>   223    <span class="xdoc"> *  Void myDeleteFxn(Task_Handle task);
</span>   224    <span class="xdoc"> *  <b>@p</b>
</span>   225    <span class="xdoc"> *
</span>   226    <span class="xdoc"> *  <b>@p(html)</b>
</span>   227    <span class="xdoc"> *  &lt;B&gt;Switch Function&lt;/B&gt;
</span>   228    <span class="xdoc"> *  <b>@p</b>
</span>   229    <span class="xdoc"> *
</span>   230    <span class="xdoc"> *  If a switch function is specified, it is invoked just before the new task
</span>   231    <span class="xdoc"> *  is switched to.  The switch function is called with interrupts enabled.
</span>   232    <span class="xdoc"> *
</span>   233    <span class="xdoc"> *  This function can be used to save/restore additional task context (for
</span>   234    <span class="xdoc"> *  example, external hardware registers), to check for task stack overflow,
</span>   235    <span class="xdoc"> *  to monitor the time used by each task, etc.
</span>   236    <span class="xdoc"> *
</span>   237    <span class="xdoc"> *  <b>@p(code)</b>
</span>   238    <span class="xdoc"> *  Void mySwitchFxn(Task_Handle prev, Task_Handle next);
</span>   239    <span class="xdoc"> *  <b>@p</b>
</span>   240    <span class="xdoc"> *
</span>   241    <span class="xdoc"> *  To properly handle the switch to the first task your switchFxn should
</span>   242    <span class="xdoc"> *  check for "prev == NULL" before using prev:
</span>   243    <span class="xdoc"> *
</span>   244    <span class="xdoc"> *  <b>@p(code)</b>
</span>   245    <span class="xdoc"> *  Void mySwitchFxn(Task_Handle prev, Task_Handle next)
</span>   246    <span class="xdoc"> *  {
</span>   247    <span class="xdoc"> *      if (prev != NULL) {
</span>   248    <span class="xdoc"> *          ...
</span>   249    <span class="xdoc"> *      }
</span>   250    <span class="xdoc"> *      ...
</span>   251    <span class="xdoc"> *  }
</span>   252    <span class="xdoc"> *  <b>@p</b>
</span>   253    <span class="xdoc"> *
</span>   254    <span class="xdoc"> *  <b>@p(html)</b>
</span>   255    <span class="xdoc"> *  &lt;B&gt;Ready Function&lt;/B&gt;
</span>   256    <span class="xdoc"> *  <b>@p</b>
</span>   257    <span class="xdoc"> *
</span>   258    <span class="xdoc"> *  If a ready function is specified, it is invoked whenever a task is made
</span>   259    <span class="xdoc"> *  ready to run.   The ready function is called  with interrupts enabled
</span>   260    <span class="xdoc"> *  (unless called at boot time or from main()).
</span>   261    <span class="xdoc"> *
</span>   262    <span class="xdoc"> *  <b>@p(code)</b>
</span>   263    <span class="xdoc"> *  Void myReadyFxn(Task_Handle task);
</span>   264    <span class="xdoc"> *  <b>@p</b>
</span>   265    <span class="xdoc"> *
</span>   266    <span class="xdoc"> *  <b>@p(html)</b>
</span>   267    <span class="xdoc"> *  &lt;B&gt;Exit Function&lt;/B&gt;
</span>   268    <span class="xdoc"> *  <b>@p</b>
</span>   269    <span class="xdoc"> *
</span>   270    <span class="xdoc"> *  If an exit function is specified, it is invoked when a task exits (via
</span>   271    <span class="xdoc"> *  call to Task_exit() or when a task returns from its' main function).
</span>   272    <span class="xdoc"> *  The Exit Function is called with interrupts enabled.
</span>   273    <span class="xdoc"> *
</span>   274    <span class="xdoc"> *  <b>@p(code)</b>
</span>   275    <span class="xdoc"> *  Void myExitFxn(Task_Handle task);
</span>   276    <span class="xdoc"> *  <b>@p</b>
</span>   277    <span class="xdoc"> *
</span>   278    <span class="xdoc"> *  <b>@p(html)</b>
</span>   279    <span class="xdoc"> *  &lt;h3&gt; Calling Context &lt;/h3&gt;
</span>   280    <span class="xdoc"> *  &lt;table border="1" cellpadding="3"&gt;
</span>   281    <span class="xdoc"> *    &lt;colgroup span="1"&gt;&lt;/colgroup&gt; &lt;colgroup span="5" align="center"&gt;
</span>   282    <span class="xdoc"> *  &lt;/colgroup&gt;
</span>   283    <span class="xdoc"> *
</span>   284    <span class="xdoc"> *    &lt;tr&gt;&lt;th&gt; Function                 &lt;/th&gt;&lt;th&gt;  Hwi   &lt;/th&gt;&lt;th&gt;  Swi   &lt;/th&gt;
</span>   285    <span class="xdoc"> *  &lt;th&gt;  Task  &lt;/th&gt;&lt;th&gt;  Main  &lt;/th&gt;&lt;th&gt;  Startup  &lt;/th&gt;&lt;/tr&gt;
</span>   286    <span class="xdoc"> *    &lt;!--                                                       --&gt;
</span>   287    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #create}          &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   288    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   289    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #disable}         &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   290    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   291    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #exit}            &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   292    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   293    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getIdleTask}     &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   294    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   295    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #Params_init}     &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   296    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>   297    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #restore}         &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   298    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   299    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #self}            &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   300    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   301    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #sleep}           &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   302    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   303    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #yield}           &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   304    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   305    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #construct}       &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   306    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   307    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #delete}          &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   308    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   309    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #destruct}        &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   310    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   311    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getEnv}          &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   312    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   313    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getHookContext}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   314    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   315    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getMode}         &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   316    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   317    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getPri}          &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   318    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   319    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getFunc}         &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   320    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   321    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #setEnv}          &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   322    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   323    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #setHookContext}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   324    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   325    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #setPri}          &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   326    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   327    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #stat}            &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   328    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   329    <span class="xdoc"> *    &lt;tr&gt;&lt;td colspan="6"&gt; Definitions: &lt;br /&gt;
</span>   330    <span class="xdoc"> *       &lt;ul&gt;
</span>   331    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Hwi&lt;/b&gt;: API is callable from a Hwi thread. &lt;/li&gt;
</span>   332    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Swi&lt;/b&gt;: API is callable from a Swi thread. &lt;/li&gt;
</span>   333    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Task&lt;/b&gt;: API is callable from a Task thread. &lt;/li&gt;
</span>   334    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Main&lt;/b&gt;: API is callable during any of these phases: &lt;/li&gt;
</span>   335    <span class="xdoc"> *           &lt;ul&gt;
</span>   336    <span class="xdoc"> *             &lt;li&gt; In your module startup after this module is started
</span>   337    <span class="xdoc"> *  (e.g. Task_Module_startupDone() returns TRUE). &lt;/li&gt;
</span>   338    <span class="xdoc"> *             &lt;li&gt; During xdc.runtime.Startup.lastFxns. &lt;/li&gt;
</span>   339    <span class="xdoc"> *             &lt;li&gt; During main().&lt;/li&gt;
</span>   340    <span class="xdoc"> *             &lt;li&gt; During BIOS.startupFxns.&lt;/li&gt;
</span>   341    <span class="xdoc"> *           &lt;/ul&gt;
</span>   342    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Startup&lt;/b&gt;: API is callable during any of these phases:&lt;/li&gt;
</span>   343    <span class="xdoc"> *           &lt;ul&gt;
</span>   344    <span class="xdoc"> *             &lt;li&gt; During xdc.runtime.Startup.firstFxns.&lt;/li&gt;
</span>   345    <span class="xdoc"> *             &lt;li&gt; In your module startup before this module is started
</span>   346    <span class="xdoc"> *  (e.g. Task_Module_startupDone() returns FALSE).&lt;/li&gt;
</span>   347    <span class="xdoc"> *           &lt;/ul&gt;
</span>   348    <span class="xdoc"> *       &lt;/ul&gt;
</span>   349    <span class="xdoc"> *    &lt;/td&gt;&lt;/tr&gt;
</span>   350    <span class="xdoc"> *
</span>   351    <span class="xdoc"> *  &lt;/table&gt;
</span>   352    <span class="xdoc"> *  <b>@p</b>
</span>   353    <span class="xdoc"> */</span>
   354    
   355    @DirectCall
   356    @ModuleStartup      <span class="comment">/* generate a call to Task_Module_startup at startup */</span>
   357    @InstanceInitStatic <span class="comment">/* Construct/Destruct CAN becalled at runtime */</span>
   358    @InstanceFinalize   <span class="comment">/* generate call to Task_Instance_finalize on delete */</span>
   359    @InstanceInitError  <span class="comment">/* instance init can fail */</span>
   360    @Template (<span class="string">"./Task.xdt"</span>) <span class="comment">/* generate function to create a SMP specific
</span>   361    <span class="comment">                            module state structure and initialize it */</span>
   362    
   363    <span class=key>module</span> Task
   364    {
   365    
   366        <span class=comment>// -------- Module Constants --------</span>
   367    
   368        <span class=comment>// -------- Module Types --------</span>
   369    
   370        <span class="xdoc">/*! Task function type definition. */</span>
   371        <span class=key>typedef</span> Void (*FuncPtr)(UArg, UArg);
   372    
   373        <span class="xdoc">/*! "All Task Blocked" function type definition. */</span>
   374        <span class=key>typedef</span> Void (*AllBlockedFuncPtr)(Void);
   375    
   376        <span class="xdoc">/*!
</span>   377    <span class="xdoc">     *  Task execution modes.
</span>   378    <span class="xdoc">     *
</span>   379    <span class="xdoc">     *  These enumerations are the range of modes or states that
</span>   380    <span class="xdoc">     *  a task can be in. A task's current mode can be gotten using
</span>   381    <span class="xdoc">     *  {<b>@link</b> #stat}.
</span>   382    <span class="xdoc">     */</span>
   383        <span class=key>enum</span> Mode {
   384            Mode_RUNNING,           <span class="xdoc">/*! Task is currently executing. */</span>
   385            Mode_READY,             <span class="xdoc">/*! Task is scheduled for execution. */</span>
   386            Mode_BLOCKED,           <span class="xdoc">/*! Task is suspended from execution. */</span>
   387            Mode_TERMINATED,        <span class="xdoc">/*! Task is terminated from execution. */</span>
   388            Mode_INACTIVE           <span class="xdoc">/*! Task is on inactive task list */</span>
   389        };
   390    
   391        <span class="xdoc">/*!
</span>   392    <span class="xdoc">     *  Task Status Buffer.
</span>   393    <span class="xdoc">     *
</span>   394    <span class="xdoc">     *  Passed to and filled in by {<b>@link</b> #stat};
</span>   395    <span class="xdoc">     */</span>
   396        <span class=key>struct</span> Stat {
   397            Int     priority;       <span class="xdoc">/*! Task priority. */</span>
   398            Ptr     stack;          <span class="xdoc">/*! Task stack. */</span>
   399            SizeT   stackSize;      <span class="xdoc">/*! Task stack size. */</span>
   400            IHeap.Handle stackHeap; <span class="xdoc">/*! Heap used to alloc stack. */</span>
   401            Ptr     env;            <span class="xdoc">/*! Global environment struct. */</span>
   402            Mode    mode;           <span class="xdoc">/*! Task's current mode. */</span>
   403            Ptr     sp;             <span class="xdoc">/*! Task's current stack pointer. */</span>
   404            SizeT   used;           <span class="xdoc">/*! max # of words used on stack. */</span>
   405        };
   406    
   407        <span class="xdoc">/*!
</span>   408    <span class="xdoc">     *  Task hook set type definition.
</span>   409    <span class="xdoc">     *
</span>   410    <span class="xdoc">     *  Sets of hook functions can be specified for the Task module.
</span>   411    <span class="xdoc">     *  See {<b>@link</b> #hookfunc Hook Functions} for details.
</span>   412    <span class="xdoc">     */</span>
   413        <span class=key>struct</span> HookSet {
   414            Void (*registerFxn)(Int);
   415            Void (*createFxn)(Handle, Error.Block *);
   416            Void (*readyFxn)(Handle);
   417            Void (*switchFxn)(Handle, Handle);
   418            Void (*exitFxn)(Handle);
   419            Void (*deleteFxn)(Handle);
   420        };
   421    
   422        <span class="xdoc">/*! "Don't care" task affinity */</span>
   423        <span class=key>const</span> UInt AFFINITY_NONE = ~(0);
   424    
   425        <span class="xdoc">/*!  <b>@_nodoc</b> */</span>
   426        <span class=key>metaonly</span> <span class=key>struct</span> BasicView {
   427            String      label;
   428            Int         priority;
   429            String      mode;
   430            String      fxn[];
   431            UArg        arg0;
   432            UArg        arg1;
   433            SizeT       stackSize;
   434            Ptr         stackBase;
   435            String      curCoreId;
   436            String      affinity;
   437        }
   438    
   439        <span class="xdoc">/*!  <b>@_nodoc</b> */</span>
   440        <span class=key>metaonly</span> <span class=key>struct</span> DetailedView {
   441            String      label;
   442            Int         priority;
   443            String      mode;
   444            String      fxn[];
   445            UArg        arg0;
   446            UArg        arg1;
   447            String      stackPeak;
   448            SizeT       stackSize;
   449            Ptr         stackBase;
   450            String      curCoreId;
   451            String      affinity;
   452            String      blockedOn;
   453        }
   454    
   455        <span class="xdoc">/*!  <b>@_nodoc</b> */</span>
   456        <span class=key>metaonly</span> <span class=key>struct</span> ModuleView {
   457            String      schedulerState;
   458            String      readyQMask[];
   459            Bool        workPending;
   460            UInt        numVitalTasks;
   461            Ptr         currentTask[];
   462            String      hwiStackPeak;
   463            SizeT       hwiStackSize;
   464            Ptr         hwiStackBase;
   465        }
   466    
   467        <span class="xdoc">/*!  <b>@_nodoc</b> (not used by view) */</span>
   468        <span class=key>metaonly</span> <span class=key>struct</span> CallStackView {
   469            Int         depth;
   470            String      decode;
   471        }
   472    
   473        <span class="xdoc">/*!  <b>@_nodoc</b> */</span>
   474        <span class=key>metaonly</span> <span class=key>struct</span> ReadyQView {
   475            Ptr         task;
   476            Ptr         next;
   477            Ptr         prev;
   478            Ptr         readyQ;
   479            String      label;
   480            Int         priority;
   481            String      mode;
   482            String      fxn[];
   483            String      curCoreId;
   484            String      affinity;
   485        }
   486    
   487        <span class="xdoc">/*! <b>@_nodoc</b> */</span>
   488        @Facet
   489        <span class=key>metaonly</span> <span class=key>config</span> ViewInfo.Instance rovViewInfo =
   490            ViewInfo.create({
   491                viewMap: [
   492                    [<span class="string">'Basic'</span>,    {type: ViewInfo.INSTANCE,     viewInitFxn: <span class="string">'viewInitBasic'</span>,    structName: <span class="string">'BasicView'</span>}],
   493                    [<span class="string">'Detailed'</span>, {type: ViewInfo.INSTANCE,     viewInitFxn: <span class="string">'viewInitDetailed'</span>, structName: <span class="string">'DetailedView'</span>}],
   494                    [<span class="string">'CallStacks'</span>,  {type: ViewInfo.TREE,         viewInitFxn: <span class="string">'viewInitCallStack'</span>, structName: <span class="string">'CallStackView'</span>}],
   495                    [<span class="string">'ReadyQs'</span>,     {type: ViewInfo.TREE_TABLE,   viewInitFxn: <span class="string">'viewInitReadyQs'</span>,   structName: <span class="string">'ReadyQView'</span>}],
   496                    [<span class="string">'Module'</span>,      {type: ViewInfo.MODULE,       viewInitFxn: <span class="string">'viewInitModule'</span>,    structName: <span class="string">'ModuleView'</span>}],
   497                ]
   498            });
   499    
   500        <span class=comment>// -------- Module Parameters --------</span>
   501    
   502        <span class=comment>// Logs</span>
   503    
   504        <span class="xdoc">/*! Logged on every task switch */</span>
   505        <span class=key>config</span> Log.Event LM_switch = {
   506            mask: Diags.USER1 | Diags.USER2,
   507            msg: <span class="string">"LM_switch: oldtsk: 0x%x, oldfunc: 0x%x, newtsk: 0x%x, newfunc: 0x%x"</span>
   508        };
   509    
   510        <span class="xdoc">/*! Logged on calls to Task_sleep */</span>
   511        <span class=key>config</span> Log.Event LM_sleep = {
   512            mask: Diags.USER1 | Diags.USER2,
   513            msg: <span class="string">"LM_sleep: tsk: 0x%x, func: 0x%x, timeout: %d"</span>
   514        };
   515    
   516        <span class="xdoc">/*! Logged when a task is made ready to run (ie Semaphore_post()) */</span>
   517        <span class=key>config</span> Log.Event LD_ready = {
   518            mask: Diags.USER2,
   519            msg: <span class="string">"LD_ready: tsk: 0x%x, func: 0x%x, pri: %d"</span>
   520        };
   521    
   522        <span class="xdoc">/*! Logged when a task is blocked (ie Semaphore_pend()) */</span>
   523        <span class=key>config</span> Log.Event LD_block = {
   524            mask: Diags.USER2,
   525            msg: <span class="string">"LD_block: tsk: 0x%x, func: 0x%x"</span>
   526        };
   527    
   528        <span class="xdoc">/*! Logged on calls to Task_yield */</span>
   529        <span class=key>config</span> Log.Event LM_yield = {
   530            mask: Diags.USER1 | Diags.USER2,
   531            msg: <span class="string">"LM_yield: tsk: 0x%x, func: 0x%x, currThread: %d"</span>
   532        };
   533    
   534        <span class="xdoc">/*! Logged on calls to Task_setPri */</span>
   535        <span class=key>config</span> Log.Event LM_setPri = {
   536            mask: Diags.USER1 | Diags.USER2,
   537            msg: <span class="string">"LM_setPri: tsk: 0x%x, func: 0x%x, oldPri: %d, newPri %d"</span>
   538        };
   539    
   540        <span class="xdoc">/*!
</span>   541    <span class="xdoc">     *  Logged when Task functions fall thru the bottom
</span>   542    <span class="xdoc">     *  or when Task_exit() is explicitly called.
</span>   543    <span class="xdoc">     */</span>
   544        <span class=key>config</span> Log.Event LD_exit = {
   545            mask: Diags.USER2,
   546            msg: <span class="string">"LD_exit: tsk: 0x%x, func: 0x%x"</span>
   547        };
   548    
   549        <span class="xdoc">/*! Logged on calls to Task_setAffinity */</span>
   550        <span class=key>config</span> Log.Event LM_setAffinity = {
   551            mask: Diags.USER1 | Diags.USER2,
   552            msg: <span class="string">"LM_setAffinity: tsk: 0x%x, func: 0x%x, oldCore: %d, oldAffinity %d, newAffinity %d"</span>
   553        };
   554    
   555        <span class="xdoc">/*! Logged on every task schedule entry */</span>
   556        <span class=key>config</span> Log.Event LM_schedule = {
   557            mask: Diags.USER3,
   558            msg: <span class="string">"LD_schedule: coreId: %d, workFlag: %d, curSetLocal: %d, curSetX: %d, curMaskLocal: %d"</span>
   559        };
   560    
   561        <span class="xdoc">/*! Logged when no scheduling work was found */</span>
   562        <span class=key>config</span> Log.Event LM_noWork = {
   563            mask: Diags.USER3,
   564            msg: <span class="string">"LD_noWork: coreId: %d, curSetLocal: %d, curSetX: %d, curMaskLocal: %d"</span>
   565        };
   566    
   567        <span class=comment>// Errors</span>
   568    
   569        <span class="xdoc">/*!
</span>   570    <span class="xdoc">     *  Error raised when a stack overflow (or corruption) is detected.
</span>   571    <span class="xdoc">     *
</span>   572    <span class="xdoc">     *  This error is raised by kernel's stack checking function.  This
</span>   573    <span class="xdoc">     *  function checks the stacks before every task switch to make sure
</span>   574    <span class="xdoc">     *  that reserved word at top of stack has not been modified.
</span>   575    <span class="xdoc">     *
</span>   576    <span class="xdoc">     *  The stack checking logic is enabled by the {<b>@link</b> #initStackFlag} and
</span>   577    <span class="xdoc">     *  {<b>@link</b> #checkStackFlag} configuration parameters.  If both of these
</span>   578    <span class="xdoc">     *  flags are set to true, the kernel will validate the stacks.
</span>   579    <span class="xdoc">     */</span>
   580        <span class=key>config</span> Error.Id E_stackOverflow  = {
   581            msg: <span class="string">"E_stackOverflow: Task 0x%x stack overflow."</span>
   582        };
   583    
   584        <span class="xdoc">/*!
</span>   585    <span class="xdoc">     *  Error raised when a task's stack pointer (SP) does not point
</span>   586    <span class="xdoc">     *  somewhere within the task's stack.
</span>   587    <span class="xdoc">     *
</span>   588    <span class="xdoc">     *  This error is raised by kernel's stack checking function.  This
</span>   589    <span class="xdoc">     *  function checks the SPs before every task switch to make sure
</span>   590    <span class="xdoc">     *  they point within the task's stack.
</span>   591    <span class="xdoc">     *
</span>   592    <span class="xdoc">     *  The stack checking logic is enabled by the {<b>@link</b> #initStackFlag} and
</span>   593    <span class="xdoc">     *  {<b>@link</b> #checkStackFlag} configuration parameters.  If both of these
</span>   594    <span class="xdoc">     *  flags are set to true, the kernel will validate the stack pointers.
</span>   595    <span class="xdoc">     */</span>
   596        <span class=key>config</span> Error.Id E_spOutOfBounds  = {
   597            msg: <span class="string">"E_spOutOfBounds: Task 0x%x stack error, SP = 0x%x."</span>
   598        };
   599    
   600        <span class=key>config</span> Error.Id E_deleteNotAllowed = {
   601            msg: <span class="string">"E_deleteNotAllowed: Task 0x%x."</span>
   602        };
   603    
   604        <span class=comment>// Asserts</span>
   605    
   606        <span class="xdoc">/*! Asserted in Task_create and Task_delete */</span>
   607        <span class=key>config</span> Assert.Id A_badThreadType = {
   608            msg: <span class="string">"A_badThreadType: Cannot create/delete a task from Hwi or Swi thread."</span>
   609        };
   610    
   611        <span class="xdoc">/*! Asserted in Task_delete */</span>
   612        <span class=key>config</span> Assert.Id A_badTaskState = {
   613            msg: <span class="string">"A_badTaskState: Can't delete a task in RUNNING state."</span>
   614        };
   615    
   616        <span class="xdoc">/*! Asserted in Task_delete */</span>
   617        <span class=key>config</span> Assert.Id A_noPendElem = {
   618            msg: <span class="string">"A_noPendElem: Not enough info to delete BLOCKED task."</span>
   619        };
   620    
   621        <span class="xdoc">/*! Asserted in Task_create */</span>
   622        <span class=key>config</span> Assert.Id A_taskDisabled = {
   623            msg: <span class="string">"A_taskDisabled: Cannot create a task when tasking is disabled."</span>
   624        };
   625    
   626        <span class="xdoc">/*! Asserted in Task_create */</span>
   627        <span class=key>config</span> Assert.Id A_badPriority = {
   628            msg: <span class="string">"A_badPriority: An invalid task priority was used."</span>
   629        };
   630    
   631        <span class="xdoc">/*! Asserted in Task_sleep */</span>
   632        <span class=key>config</span> Assert.Id A_badTimeout = {
   633            msg: <span class="string">"A_badTimeout: Can't sleep FOREVER."</span>
   634        };
   635    
   636        <span class="xdoc">/*! Asserted in Task_setAffinity */</span>
   637        <span class=key>config</span> Assert.Id A_badAffinity = {
   638            msg: <span class="string">"A_badAffinity: Invalid affinity."</span>
   639        };
   640    
   641        <span class="xdoc">/*! Asserted in Task_sleep */</span>
   642        <span class=key>config</span> Assert.Id A_sleepTaskDisabled = {
   643            msg: <span class="string">"A_sleepTaskDisabled: Cannot call Task_sleep() while the Task scheduler is disabled."</span>
   644        };
   645    
   646        <span class="xdoc">/*! Asserted in Task_getIdleTaskHandle */</span>
   647        <span class=key>config</span> Assert.Id A_invalidCoreId = {
   648            msg: <span class="string">"A_invalidCoreId: Cannot pass a non-zero CoreId in a non-SMP application."</span>
   649        };
   650    
   651        <span class="xdoc">/*!
</span>   652    <span class="xdoc">     *  Number of Task priorities supported. Default is 16.
</span>   653    <span class="xdoc">     *
</span>   654    <span class="xdoc">     *  The maximum number of priorities supported is
</span>   655    <span class="xdoc">     *  target specific and depends on the number of
</span>   656    <span class="xdoc">     *  bits in a UInt data type. For 6x and ARM devices
</span>   657    <span class="xdoc">     *  the maximum number of priorities is therefore 32.
</span>   658    <span class="xdoc">     *  For 28x, 55x, and MSP430 devices, the maximum number of
</span>   659    <span class="xdoc">     *  priorities is 16.
</span>   660    <span class="xdoc">     */</span>
   661        <span class=key>config</span> UInt numPriorities = 16;
   662    
   663        <span class="xdoc">/*!
</span>   664    <span class="xdoc">     *  Default stack size (in MAUs) used for all tasks.
</span>   665    <span class="xdoc">     *
</span>   666    <span class="xdoc">     *  Default is obtained from the family-specific TaskSupport module
</span>   667    <span class="xdoc">      *  (e.g. {<b>@link</b> ti.sysbios.family.arm.m3.TaskSupport},
</span>   668    <span class="xdoc">      *  {<b>@link</b> ti.sysbios.family.c62.TaskSupport}).
</span>   669    <span class="xdoc">     */</span>
   670        <span class=key>config</span> SizeT defaultStackSize;
   671    
   672        <span class="xdoc">/*!
</span>   673    <span class="xdoc">     *  Default memory section used for all statically created task stacks.
</span>   674    <span class="xdoc">     *
</span>   675    <span class="xdoc">     *  The default stack section name is target/device specific.
</span>   676    <span class="xdoc">     *  For C6x targets it is ".far:taskStackSection".
</span>   677    <span class="xdoc">     *  For C28x targets it is ".taskStackSection".
</span>   678    <span class="xdoc">     *  For GNU targets it is ".bss".
</span>   679    <span class="xdoc">     *  For all other targets it is ".bss:taskStackSection".
</span>   680    <span class="xdoc">     *
</span>   681    <span class="xdoc">     *  By default, all statically created task stacks are grouped together
</span>   682    <span class="xdoc">     *  into the defaultStackSection and placed where ever
</span>   683    <span class="xdoc">     *  the target specific defaultStackSection base section name
</span>   684    <span class="xdoc">     *  (ie .bss, .far, .ebss) is placed.
</span>   685    <span class="xdoc">     *
</span>   686    <span class="xdoc">     *  To place all task stacks into a different memory segment,
</span>   687    <span class="xdoc">     *  add the following to your config script:
</span>   688    <span class="xdoc">     *
</span>   689    <span class="xdoc">     *  <b>@p(code)</b>
</span>   690    <span class="xdoc">     *  Program.sectMap[Task.defaultStackSection] = new Program.SectionSpec();
</span>   691    <span class="xdoc">     *  Program.sectMap[Task.defaultStackSection].loadSegment =
</span>   692    <span class="xdoc">     *                   "yourMemorySegment";
</span>   693    <span class="xdoc">     *  <b>@p</b>
</span>   694    <span class="xdoc">     *
</span>   695    <span class="xdoc">     *  To group all task stacks into a different section AND place that
</span>   696    <span class="xdoc">     *  section into a specific memory segment, add the following to your
</span>   697    <span class="xdoc">     *  config script:
</span>   698    <span class="xdoc">     *
</span>   699    <span class="xdoc">     *  <b>@p(code)</b>
</span>   700    <span class="xdoc">     *  Task.defaultStackSection = ".yourSectionName";
</span>   701    <span class="xdoc">     *  Program.sectMap[Task.defaultStackSection] = new Program.SectionSpec();
</span>   702    <span class="xdoc">     *  Program.sectMap[Task.defaultStackSection].loadSegment =
</span>   703    <span class="xdoc">     *                   "yourMemorySegment";
</span>   704    <span class="xdoc">     *  <b>@p</b>
</span>   705    <span class="xdoc">     *
</span>   706    <span class="xdoc">     *  Where "yourSectionName" can be just about anything, and
</span>   707    <span class="xdoc">     *                   "yourMemorySegment"
</span>   708    <span class="xdoc">     *  must be a memory segment defined for your board.
</span>   709    <span class="xdoc">     */</span>
   710        <span class=key>metaonly</span> <span class=key>config</span> String defaultStackSection;
   711    
   712        <span class="xdoc">/*!
</span>   713    <span class="xdoc">     *  Default Mem heap used for all dynamically created task stacks.
</span>   714    <span class="xdoc">     *
</span>   715    <span class="xdoc">     *  Default is null.
</span>   716    <span class="xdoc">     */</span>
   717        <span class=key>config</span> IHeap.Handle defaultStackHeap;
   718    
   719        <span class="xdoc">/*!
</span>   720    <span class="xdoc">     *  Default core affinity for newly created tasks.
</span>   721    <span class="xdoc">     *
</span>   722    <span class="xdoc">     *  Default is Task_AFFINITY_NONE, meaning don't care.
</span>   723    <span class="xdoc">     */</span>
   724        <span class=key>metaonly</span> <span class=key>config</span> UInt defaultAffinity = AFFINITY_NONE;
   725    
   726        <span class="xdoc">/*!
</span>   727    <span class="xdoc">     *  Create a task (of priority 0) to run the Idle functions in.
</span>   728    <span class="xdoc">     *
</span>   729    <span class="xdoc">     *  When set to true, a task is created that continuously calls the
</span>   730    <span class="xdoc">     *  {<b>@link</b> Idle#run Idle_run()} function, which, in turn calls each of
</span>   731    <span class="xdoc">     *  the configured Idle functions.
</span>   732    <span class="xdoc">     *
</span>   733    <span class="xdoc">     *  When set to false, no Idle Task is created and it is up to the
</span>   734    <span class="xdoc">     *  user to call the Idle_run() function if the configured Idle
</span>   735    <span class="xdoc">     *  functions need to be run. Or, by adding the following lines to
</span>   736    <span class="xdoc">     *  the config script, the Idle functions will run whenever all
</span>   737    <span class="xdoc">     *  tasks are blocked ({<b>@link</b> #allBlockedFunc Task.allBlockedFunc}):
</span>   738    <span class="xdoc">     *
</span>   739    <span class="xdoc">     *  <b>@p(code)</b>
</span>   740    <span class="xdoc">     *  Task.enableIdleTask = false;
</span>   741    <span class="xdoc">     *  Task.allBlockedFunc = Idle.run;
</span>   742    <span class="xdoc">     *  <b>@p</b>
</span>   743    <span class="xdoc">     *
</span>   744    <span class="xdoc">     *  Default is true.
</span>   745    <span class="xdoc">     *
</span>   746    <span class="xdoc">     *  <b>@see</b> #idleTaskStackSize
</span>   747    <span class="xdoc">     *  <b>@see</b> #idleTaskStackSection
</span>   748    <span class="xdoc">     *  <b>@see</b> #idleTaskVitalTaskFlag
</span>   749    <span class="xdoc">     *  <b>@see</b> #allBlockedFunc
</span>   750    <span class="xdoc">     */</span>
   751        <span class=key>metaonly</span> <span class=key>config</span> Bool enableIdleTask = <span class=key>true</span>;
   752    
   753        <span class="xdoc">/*!
</span>   754    <span class="xdoc">     *  Idle task stack size in MAUs.
</span>   755    <span class="xdoc">     *
</span>   756    <span class="xdoc">     *  Default is inherited from module config defaultStackSize.
</span>   757    <span class="xdoc">     */</span>
   758        <span class=key>metaonly</span> <span class=key>config</span> SizeT idleTaskStackSize;
   759    
   760        <span class="xdoc">/*!
</span>   761    <span class="xdoc">     *  Idle task stack section
</span>   762    <span class="xdoc">     *
</span>   763    <span class="xdoc">     *  Default is inherited from module config defaultStackSection;
</span>   764    <span class="xdoc">     */</span>
   765        <span class=key>metaonly</span> <span class=key>config</span> String idleTaskStackSection;
   766    
   767        <span class="xdoc">/*!
</span>   768    <span class="xdoc">     *  Idle task's vitalTaskFlag.
</span>   769    <span class="xdoc">     *  (see {<b>@link</b> #vitalTaskFlag}).
</span>   770    <span class="xdoc">     *
</span>   771    <span class="xdoc">     *  Default is true.
</span>   772    <span class="xdoc">     */</span>
   773        <span class=key>metaonly</span> <span class=key>config</span> Bool idleTaskVitalTaskFlag = <span class=key>true</span>;
   774    
   775        <span class="xdoc">/*!
</span>   776    <span class="xdoc">     *  Function to call while all tasks are blocked.
</span>   777    <span class="xdoc">     *
</span>   778    <span class="xdoc">     *  This function will be called repeatedly while no tasks are
</span>   779    <span class="xdoc">     *  ready to run.
</span>   780    <span class="xdoc">     *
</span>   781    <span class="xdoc">     *  Ordinarily (in applications that have tasks ready to run at startup),
</span>   782    <span class="xdoc">     *  the function will run in the context of the last task to block.
</span>   783    <span class="xdoc">     *
</span>   784    <span class="xdoc">     *  In an application where there are no tasks ready to run
</span>   785    <span class="xdoc">     *  when BIOS_start() is called, the allBlockedFunc function is
</span>   786    <span class="xdoc">     *  called within the BIOS_start() thread which runs on the system/ISR
</span>   787    <span class="xdoc">     *  stack.
</span>   788    <span class="xdoc">     *
</span>   789    <span class="xdoc">     *  By default, allBlockedFunc is initialized to point to an internal
</span>   790    <span class="xdoc">     *  function that simply returns.
</span>   791    <span class="xdoc">     *
</span>   792    <span class="xdoc">     *  By adding the following lines to the config script, the Idle
</span>   793    <span class="xdoc">     *  functions will run whenever all tasks are blocked:
</span>   794    <span class="xdoc">     *
</span>   795    <span class="xdoc">     *  <b>@p(code)</b>
</span>   796    <span class="xdoc">     *  Task.enableIdleTask = false;
</span>   797    <span class="xdoc">     *  Task.allBlockedFunc = Idle.run;
</span>   798    <span class="xdoc">     *  <b>@p</b>
</span>   799    <span class="xdoc">     *
</span>   800    <span class="xdoc">     *  <b>@see</b> #enableIdleTask
</span>   801    <span class="xdoc">     *
</span>   802    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   803    <span class="xdoc">     *  The configured allBlockedFunc is designed to be called repeatedly.
</span>   804    <span class="xdoc">     *  It must return in order for the task scheduler to check if all
</span>   805    <span class="xdoc">     *  tasks are STILL blocked and if not, run the highest priority task
</span>   806    <span class="xdoc">     *  currently ready to run.
</span>   807    <span class="xdoc">     *
</span>   808    <span class="xdoc">     *  The configured allBlockedFunc function is called with interrupts
</span>   809    <span class="xdoc">     *  disabled. If your function must run with interrupts enabled,
</span>   810    <span class="xdoc">     *  surround the body of your code with  Hwi_enable()/Hwi_restore()
</span>   811    <span class="xdoc">     *  function calls per the following example:
</span>   812    <span class="xdoc">     *
</span>   813    <span class="xdoc">     *  <b>@p(code)</b>
</span>   814    <span class="xdoc">     *  Void yourFunc() {
</span>   815    <span class="xdoc">     *      UInt hwiKey;
</span>   816    <span class="xdoc">     *
</span>   817    <span class="xdoc">     *      hwiKey = Hwi_enable();
</span>   818    <span class="xdoc">     *
</span>   819    <span class="xdoc">     *      ...         // your code here
</span>   820    <span class="xdoc">     *
</span>   821    <span class="xdoc">     *      Hwi_restore(hwiKey);
</span>   822    <span class="xdoc">     *  }
</span>   823    <span class="xdoc">     *  <b>@p</b>
</span>   824    <span class="xdoc">     */</span>
   825        <span class=key>config</span> AllBlockedFuncPtr allBlockedFunc = <span class=key>null</span>;
   826    
   827        <span class="xdoc">/*!
</span>   828    <span class="xdoc">     *  Initialize stack with known value for stack checking at runtime
</span>   829    <span class="xdoc">     *  (see {<b>@link</b> #checkStackFlag}).
</span>   830    <span class="xdoc">     *
</span>   831    <span class="xdoc">     *  This is also useful for inspection of stack in debugger or core
</span>   832    <span class="xdoc">     *  dump utilities.
</span>   833    <span class="xdoc">     *  Default is true.
</span>   834    <span class="xdoc">     */</span>
   835        <span class=key>config</span> Bool initStackFlag = <span class=key>true</span>;
   836    
   837        <span class="xdoc">/*!
</span>   838    <span class="xdoc">     *  Check 'from' and 'to' task stacks before task context switch.
</span>   839    <span class="xdoc">     *
</span>   840    <span class="xdoc">     *  The check consists of testing the top of stack value against
</span>   841    <span class="xdoc">     *  its initial value (see {<b>@link</b> #initStackFlag}). If it is no
</span>   842    <span class="xdoc">     *  longer at this value, the assumption is that the task has
</span>   843    <span class="xdoc">     *  overrun its stack. If the test fails, then the
</span>   844    <span class="xdoc">     *  {<b>@link</b> #E_stackOverflow} error is raised.
</span>   845    <span class="xdoc">     *
</span>   846    <span class="xdoc">     *  Runtime stack checking is only performed if {<b>@link</b> #initStackFlag} is
</span>   847    <span class="xdoc">     *  also true.
</span>   848    <span class="xdoc">     *
</span>   849    <span class="xdoc">     *  Default is true.
</span>   850    <span class="xdoc">     *
</span>   851    <span class="xdoc">     *  To enable or disable full stack checking, you should set both this
</span>   852    <span class="xdoc">     *  flag and the {<b>@link</b> ti.sysbios.hal.Hwi#checkStackFlag}.
</span>   853    <span class="xdoc">     *
</span>   854    <span class="xdoc">     *  <b>@a(Note)</b>
</span>   855    <span class="xdoc">     *  Enabling stack checking will add some interrupt latency because the
</span>   856    <span class="xdoc">     *  checks are made within the Task scheduler while interrupts are
</span>   857    <span class="xdoc">     *  disabled.
</span>   858    <span class="xdoc">     */</span>
   859        <span class=key>config</span> Bool checkStackFlag = <span class=key>true</span>;
   860    
   861        <span class="xdoc">/*!
</span>   862    <span class="xdoc">     *  Automatically delete terminated tasks.
</span>   863    <span class="xdoc">     *
</span>   864    <span class="xdoc">     *  If this feature is enabled, an Idle function is installed that
</span>   865    <span class="xdoc">     *  deletes dynamically created Tasks that have terminated either
</span>   866    <span class="xdoc">     *  by falling through their task function or by explicitly calling
</span>   867    <span class="xdoc">     *  Task_exit().
</span>   868    <span class="xdoc">     *
</span>   869    <span class="xdoc">     *  A list of terminated Tasks that were created dynmically is
</span>   870    <span class="xdoc">     *  maintained internally. Each invocation of the installed Idle function
</span>   871    <span class="xdoc">     *  deletes the first Task on this list. This one-at-a-time process
</span>   872    <span class="xdoc">     *  continues until the list is empty.
</span>   873    <span class="xdoc">     *
</span>   874    <span class="xdoc">     *  <b>@a(Note)</b>
</span>   875    <span class="xdoc">     *  This feature is disabled by default.
</span>   876    <span class="xdoc">     *
</span>   877    <span class="xdoc">     *  <b>@a(WARNING)</b>
</span>   878    <span class="xdoc">     *  When this feature is enabled, an error will be raised if the user's
</span>   879    <span class="xdoc">     *  application attempts to delete a terminated task. If a terminated task
</span>   880    <span class="xdoc">     *  has already been automatically deleted and THEN the user's application
</span>   881    <span class="xdoc">     *  attempts to delete it (ie: using a stale Task handle), the results are
</span>   882    <span class="xdoc">     *  undefined and probably catastrophic!
</span>   883    <span class="xdoc">     *
</span>   884    <span class="xdoc">     */</span>
   885        <span class=key>config</span> Bool deleteTerminatedTasks = <span class=key>false</span>;
   886    
   887        <span class="xdoc">/*!
</span>   888    <span class="xdoc">     *  Const array that holds the HookSet objects.
</span>   889    <span class="xdoc">     *
</span>   890    <span class="xdoc">     *  See {<b>@link</b> #hookfunc Hook Functions} for details about HookSets.
</span>   891    <span class="xdoc">     */</span>
   892        <span class=key>config</span> HookSet hooks[<span class=key>length</span>] = [];
   893    
   894        <span class=comment>// -------- Module Functions --------</span>
   895    
   896        <span class="xdoc">/*!
</span>   897    <span class="xdoc">     *  ======== addHookSet ========
</span>   898    <span class="xdoc">     *  addHookSet is used in a config file to add a hook set.
</span>   899    <span class="xdoc">     *
</span>   900    <span class="xdoc">     *  Configures a set of hook functions for the
</span>   901    <span class="xdoc">     *  Task module. Each set contains these hook functions:
</span>   902    <span class="xdoc">     *
</span>   903    <span class="xdoc">     *  <b>@p(blist)</b>
</span>   904    <span class="xdoc">     *  -Register: A function called before any statically created tasks
</span>   905    <span class="xdoc">     *  are initialized at runtime.  The register hook is called at boot time
</span>   906    <span class="xdoc">     *  before main() and before interrupts are enabled.
</span>   907    <span class="xdoc">     *  -Create: A function that is called when a task is created.
</span>   908    <span class="xdoc">     *  This includes tasks that are created statically and those
</span>   909    <span class="xdoc">     *  created dynamically using {<b>@link</b> #create} or {<b>@link</b> #construct}.
</span>   910    <span class="xdoc">     *  The create hook is called outside of a Task_disable/enable block and
</span>   911    <span class="xdoc">     *   before the task has been added to the ready list.
</span>   912    <span class="xdoc">     *  -Ready: A function that is called when a task becomes ready to run.
</span>   913    <span class="xdoc">     *   The ready hook is called from within a Task_disable/enable block with
</span>   914    <span class="xdoc">     *   interrupts enabled.
</span>   915    <span class="xdoc">     *  -Switch: A function that is called just before a task switch
</span>   916    <span class="xdoc">     *  occurs. The 'prev' and 'next' task handles are passed to the Switch
</span>   917    <span class="xdoc">     *  hook. 'prev' is set to NULL for the initial task switch that occurs
</span>   918    <span class="xdoc">     *  during SYS/BIOS startup.  The Switch hook is called from within a
</span>   919    <span class="xdoc">     *  Task_disable/enable block with interrupts enabled.
</span>   920    <span class="xdoc">     *  -Exit:  A function that is called when a task exits using
</span>   921    <span class="xdoc">     *  {<b>@link</b> #exit}.  The exit hook is passed the handle of the exiting
</span>   922    <span class="xdoc">     *  task.  The exit hook is called outside of a Task_disable/enable block
</span>   923    <span class="xdoc">     *  and before the task has been removed from the kernel lists.
</span>   924    <span class="xdoc">     *  -Delete: A function that is called when any task is deleted at
</span>   925    <span class="xdoc">     *  run-time with {<b>@link</b> #delete}.  The delete hook is called outside
</span>   926    <span class="xdoc">     *  of a Task_disable/enable block.
</span>   927    <span class="xdoc">     *  <b>@p</b>
</span>   928    <span class="xdoc">     *  Hook functions can only be configured statically.
</span>   929    <span class="xdoc">     *
</span>   930    <span class="xdoc">     *  See {<b>@link</b> #hookfunc Hook Functions} for more details.
</span>   931    <span class="xdoc">     *
</span>   932    <span class="xdoc">     *  HookSet structure elements may be omitted, in which case those
</span>   933    <span class="xdoc">     *  elements will not exist.
</span>   934    <span class="xdoc">     *
</span>   935    <span class="xdoc">     *  For example, the following configuration code defines a HookSet:
</span>   936    <span class="xdoc">     *
</span>   937    <span class="xdoc">     *  <b>@p(code)</b>
</span>   938    <span class="xdoc">     *  // Hook Set 1
</span>   939    <span class="xdoc">     *  Task.addHookSet({
</span>   940    <span class="xdoc">     *     registerFxn: '&amp;myRegister1',
</span>   941    <span class="xdoc">     *     createFxn:   '&amp;myCreate1',
</span>   942    <span class="xdoc">     *     readyFxn:    '&amp;myReady1',
</span>   943    <span class="xdoc">     *     switchFxn:   '&amp;mySwitch1',
</span>   944    <span class="xdoc">     *     exitFxn:     '&amp;myExit1',
</span>   945    <span class="xdoc">     *     deleteFxn:   '&amp;myDelete1'
</span>   946    <span class="xdoc">     *  });
</span>   947    <span class="xdoc">     *  <b>@p</b>
</span>   948    <span class="xdoc">     *
</span>   949    <span class="xdoc">     *  <b>@param(hook)</b>    structure of type HookSet
</span>   950    <span class="xdoc">     */</span>
   951        <span class=key>metaonly</span> Void addHookSet(HookSet hook);
   952    
   953        <span class="xdoc">/*!
</span>   954    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   955    <span class="xdoc">     *  ======== Task_startup ========
</span>   956    <span class="xdoc">     *  Start the task scheduler.
</span>   957    <span class="xdoc">     *
</span>   958    <span class="xdoc">     *  Task_startup signals the end of boot operations, enables
</span>   959    <span class="xdoc">     *  the Task scheduler and schedules the highest priority ready
</span>   960    <span class="xdoc">     *  task for execution.
</span>   961    <span class="xdoc">     *
</span>   962    <span class="xdoc">     *  Task_startup is called by BIOS_start() after Hwi_enable()
</span>   963    <span class="xdoc">     *  and Swi_enable(). There is no return from this function as the
</span>   964    <span class="xdoc">     *  execution thread is handed to the highest priority ready task.
</span>   965    <span class="xdoc">     */</span>
   966        Void startup();
   967    
   968        <span class="xdoc">/*!
</span>   969    <span class="xdoc">     *  ======== Task_enabled ========
</span>   970    <span class="xdoc">     *  Returns TRUE if the Task scheduler is enabled
</span>   971    <span class="xdoc">     *
</span>   972    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   973    <span class="xdoc">     */</span>
   974        Bool enabled();
   975    
   976        <span class="xdoc">/*!
</span>   977    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   978    <span class="xdoc">     *  ======== unlockSched ========
</span>   979    <span class="xdoc">     *  Force a Task scheduler unlock. Used by Core_atExit() &amp; Core_hwiFunc()
</span>   980    <span class="xdoc">     *  to unlock Task scheduler before exiting.
</span>   981    <span class="xdoc">     *
</span>   982    <span class="xdoc">     *  This function should only be called after a Hwi_disable() has entered
</span>   983    <span class="xdoc">     *  the Inter-core gate and disabled interrupts locally.
</span>   984    <span class="xdoc">     */</span>
   985        Void unlockSched();
   986    
   987        <span class="xdoc">/*!
</span>   988    <span class="xdoc">     *  ======== Task_disable ========
</span>   989    <span class="xdoc">     *  Disable the task scheduler.
</span>   990    <span class="xdoc">     *
</span>   991    <span class="xdoc">     *  {<b>@link</b> #disable} and {<b>@link</b> #restore} control Task scheduling.
</span>   992    <span class="xdoc">     *  {<b>@link</b> #disable} disables all other Tasks from running until
</span>   993    <span class="xdoc">     *  {<b>@link</b> #restore} is called. Hardware and Software interrupts
</span>   994    <span class="xdoc">     *  can still run.
</span>   995    <span class="xdoc">     *
</span>   996    <span class="xdoc">     *  {<b>@link</b> #disable} and {<b>@link</b> #restore} allow you to ensure that
</span>   997    <span class="xdoc">     *  statements
</span>   998    <span class="xdoc">     *  that must be performed together during critical processing are not
</span>   999    <span class="xdoc">     *  preempted by other Tasks.
</span>  1000    <span class="xdoc">     *
</span>  1001    <span class="xdoc">     *  The value of the key returned is opaque to applications and is meant
</span>  1002    <span class="xdoc">     *  to be passed to Task_restore().
</span>  1003    <span class="xdoc">     *
</span>  1004    <span class="xdoc">     *  In the following example, the critical section is
</span>  1005    <span class="xdoc">     *  not preempted by any Tasks.
</span>  1006    <span class="xdoc">     *
</span>  1007    <span class="xdoc">     *  <b>@p(code)</b>
</span>  1008    <span class="xdoc">     *  key = Task_disable();
</span>  1009    <span class="xdoc">     *      `critical section`
</span>  1010    <span class="xdoc">     *  Task_restore(key);
</span>  1011    <span class="xdoc">     *  <b>@p</b>
</span>  1012    <span class="xdoc">     *
</span>  1013    <span class="xdoc">     *  You can also use {<b>@link</b> #disable} and {<b>@link</b> #restore} to
</span>  1014    <span class="xdoc">     *  create several Tasks and allow them to be invoked in
</span>  1015    <span class="xdoc">     *  priority order.
</span>  1016    <span class="xdoc">     *
</span>  1017    <span class="xdoc">     *  {<b>@link</b> #disable} calls can be nested.
</span>  1018    <span class="xdoc">     *
</span>  1019    <span class="xdoc">     *  <b>@b(returns)</b>     key for use with {<b>@link</b> #restore}
</span>  1020    <span class="xdoc">     *
</span>  1021    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>  1022    <span class="xdoc">     *  Do not call any function that can cause the current task to block
</span>  1023    <span class="xdoc">     *  within a {<b>@link</b> #disable}/{<b>@link</b> #restore} block. For example,
</span>  1024    <span class="xdoc">     *  {<b>@link</b> ti.sysbios.knl.Semaphore#pend Semaphore_pend}
</span>  1025    <span class="xdoc">     *  (if timeout is non-zero),
</span>  1026    <span class="xdoc">     *  {<b>@link</b> #sleep}, {<b>@link</b> #yield}, and Memory_alloc can all
</span>  1027    <span class="xdoc">     *  cause blocking.
</span>  1028    <span class="xdoc">     */</span>
  1029        UInt disable();
  1030    
  1031        <span class="xdoc">/*!
</span>  1032    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1033    <span class="xdoc">     *  ======== enable ========
</span>  1034    <span class="xdoc">     *  Enable the task scheduler.
</span>  1035    <span class="xdoc">     *
</span>  1036    <span class="xdoc">     *  {<b>@link</b> #enable} unconditionally enables the Task scheduler and
</span>  1037    <span class="xdoc">     *  schedules the highest priority ready task for execution.
</span>  1038    <span class="xdoc">     *
</span>  1039    <span class="xdoc">     *  This function is called by {<b>@link</b> #startup} (which is called by
</span>  1040    <span class="xdoc">     *  {<b>@link</b> ti.sysbios.BIOS#start BIOS_start}) to begin multi-tasking
</span>  1041    <span class="xdoc">     *  operations.
</span>  1042    <span class="xdoc">     */</span>
  1043        Void enable();
  1044    
  1045        <span class="xdoc">/*!
</span>  1046    <span class="xdoc">     *  ======== restore ========
</span>  1047    <span class="xdoc">     *  Restore Task scheduling state.
</span>  1048    <span class="xdoc">     *
</span>  1049    <span class="xdoc">     *  {<b>@link</b> #disable} and {<b>@link</b> #restore} control Task scheduling
</span>  1050    <span class="xdoc">     *  {<b>@link</b> #disable} disables all other Tasks from running until
</span>  1051    <span class="xdoc">     *  {<b>@link</b> #restore} is called. Hardware and Software interrupts
</span>  1052    <span class="xdoc">     *  can still run.
</span>  1053    <span class="xdoc">     *
</span>  1054    <span class="xdoc">     *  {<b>@link</b> #disable} and {<b>@link</b> #restore} allow you to ensure that
</span>  1055    <span class="xdoc">     *  statements
</span>  1056    <span class="xdoc">     *  that must be performed together during critical processing are not
</span>  1057    <span class="xdoc">     *  preempted.
</span>  1058    <span class="xdoc">
</span>  1059    <span class="xdoc">     *  In the following example, the critical section is not preempted
</span>  1060    <span class="xdoc">     *  by any Tasks.
</span>  1061    <span class="xdoc">     *
</span>  1062    <span class="xdoc">     *  <b>@p(code)</b>
</span>  1063    <span class="xdoc">     *  key = Task_disable();
</span>  1064    <span class="xdoc">     *      `critical section`
</span>  1065    <span class="xdoc">     *  Task_restore(key);
</span>  1066    <span class="xdoc">     *  <b>@p</b>
</span>  1067    <span class="xdoc">     *
</span>  1068    <span class="xdoc">     *  You can also use {<b>@link</b> #disable} and {<b>@link</b> #restore} to create
</span>  1069    <span class="xdoc">     *  several Tasks and allow them to be performed in priority order.
</span>  1070    <span class="xdoc">     *
</span>  1071    <span class="xdoc">     *  {<b>@link</b> #disable} calls can be nested.
</span>  1072    <span class="xdoc">     *
</span>  1073    <span class="xdoc">     *  {<b>@link</b> #restore} returns with interrupts enabled if the key unlocks
</span>  1074    <span class="xdoc">     *  the scheduler
</span>  1075    <span class="xdoc">     *
</span>  1076    <span class="xdoc">     *  <b>@param(key)</b>     key to restore previous Task scheduler state
</span>  1077    <span class="xdoc">     *
</span>  1078    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>  1079    <span class="xdoc">     *  Do not call any function that can cause the current task to block
</span>  1080    <span class="xdoc">     *  within a {<b>@link</b> #disable}/{<b>@link</b> #restore} block. For example,
</span>  1081    <span class="xdoc">     *  {<b>@link</b> ti.sysbios.knl.Semaphore#pend Semaphore_pend()}
</span>  1082    <span class="xdoc">     *  (if timeout is non-zero),
</span>  1083    <span class="xdoc">     *  {<b>@link</b> #sleep}, {<b>@link</b> #yield}, and Memory_alloc can all
</span>  1084    <span class="xdoc">     *  cause blocking.
</span>  1085    <span class="xdoc">     *
</span>  1086    <span class="xdoc">     *  {<b>@link</b> #restore} internally calls Hwi_enable() if the key passed
</span>  1087    <span class="xdoc">     *  to it results in the unlocking of the Task scheduler (ie if this
</span>  1088    <span class="xdoc">     *  is root Task_disable/Task_restore pair).
</span>  1089    <span class="xdoc">     */</span>
  1090        Void restore(UInt key);
  1091    
  1092        <span class="xdoc">/*!
</span>  1093    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1094    <span class="xdoc">     *  ======== restoreHwi ========
</span>  1095    <span class="xdoc">     *  Restore Task scheduling state.
</span>  1096    <span class="xdoc">     *  Used by dispatcher. Does not re-enable Ints.
</span>  1097    <span class="xdoc">     */</span>
  1098        Void restoreHwi(UInt key);
  1099    
  1100        <span class="xdoc">/*!
</span>  1101    <span class="xdoc">     *  ======== self ========
</span>  1102    <span class="xdoc">     *  Returns a handle to the currently executing Task object.
</span>  1103    <span class="xdoc">     *
</span>  1104    <span class="xdoc">     *  Task_self returns the object handle for the currently executing task.
</span>  1105    <span class="xdoc">     *  This function is useful when inspecting the object or when the current
</span>  1106    <span class="xdoc">     *  task changes its own priority through {<b>@link</b> #setPri}.
</span>  1107    <span class="xdoc">     *
</span>  1108    <span class="xdoc">     *  No task switch occurs when calling Task_self.
</span>  1109    <span class="xdoc">     *
</span>  1110    <span class="xdoc">     *  Task_self will return NULL until Tasking is initiated at the end of
</span>  1111    <span class="xdoc">     *  BIOS_start().
</span>  1112    <span class="xdoc">     *
</span>  1113    <span class="xdoc">     *  <b>@b(returns)</b>     address of currently executing task object
</span>  1114    <span class="xdoc">     */</span>
  1115        Handle self();
  1116    
  1117        <span class="xdoc">/*!
</span>  1118    <span class="xdoc">     *  ======== selfMacro ========
</span>  1119    <span class="xdoc">     *  Returns a handle to the currently executing Task object.
</span>  1120    <span class="xdoc">     *
</span>  1121    <span class="xdoc">     *  Task_selfMacro is identical to {<b>@link</b> #self} but is implemented as
</span>  1122    <span class="xdoc">     *  and inline macro.
</span>  1123    <span class="xdoc">     *
</span>  1124    <span class="xdoc">     *  <b>@b(returns)</b>     address of currently executing task object
</span>  1125    <span class="xdoc">     */</span>
  1126        @Macro
  1127        Handle selfMacro();
  1128    
  1129        <span class="xdoc">/*!
</span>  1130    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1131    <span class="xdoc">     *  ======== checkStacks ========
</span>  1132    <span class="xdoc">     *  Check for stack overflow.
</span>  1133    <span class="xdoc">     *
</span>  1134    <span class="xdoc">     *  This function is usually called by the {<b>@link</b> #HookSet} switchFxn to
</span>  1135    <span class="xdoc">     *  make sure task stacks are valid before performing the context
</span>  1136    <span class="xdoc">     *  switch.
</span>  1137    <span class="xdoc">     *
</span>  1138    <span class="xdoc">     *  If a stack overflow is detected on either the oldTask or the
</span>  1139    <span class="xdoc">     *  newTask, a {<b>@link</b> #E_stackOverflow} Error is raised and the system
</span>  1140    <span class="xdoc">     *  exited.
</span>  1141    <span class="xdoc">     *
</span>  1142    <span class="xdoc">     *  In order to work properly, {<b>@link</b> #checkStacks} requires that the
</span>  1143    <span class="xdoc">     *  {<b>@link</b> #initStackFlag} set to true, which it is by default.
</span>  1144    <span class="xdoc">     *
</span>  1145    <span class="xdoc">     *  You can call {<b>@link</b> #checkStacks} directly from your application.
</span>  1146    <span class="xdoc">     *  For example, you can check the current task's stack integrity
</span>  1147    <span class="xdoc">     *  at any time with a call like the following:
</span>  1148    <span class="xdoc">     *
</span>  1149    <span class="xdoc">     *  <b>@p(code)</b>
</span>  1150    <span class="xdoc">     *  Task_checkStacks(Task_self(), Task_self());
</span>  1151    <span class="xdoc">     *  <b>@p</b>
</span>  1152    <span class="xdoc">     *
</span>  1153    <span class="xdoc">     *  <b>@param(oldTask)</b>  leaving Task Object Ptr
</span>  1154    <span class="xdoc">     *  <b>@param(newTask)</b>  entering Task Object Ptr
</span>  1155    <span class="xdoc">     */</span>
  1156        Void checkStacks(Handle oldTask, Handle newTask);
  1157    
  1158        <span class="xdoc">/*!
</span>  1159    <span class="xdoc">     *  ======== exit ========
</span>  1160    <span class="xdoc">     *  Terminate execution of the current task.
</span>  1161    <span class="xdoc">     *
</span>  1162    <span class="xdoc">     *  Task_exit terminates execution of the current task, changing its mode
</span>  1163    <span class="xdoc">     *  from {<b>@link</b> #Mode_RUNNING} to {<b>@link</b> #Mode_TERMINATED}. If all tasks
</span>  1164    <span class="xdoc">     *  have been terminated, or if all remaining tasks have their
</span>  1165    <span class="xdoc">     *  vitalTaskFlag attribute set to FALSE, then SYS/BIOS terminates the
</span>  1166    <span class="xdoc">     *  program as a whole by calling the function System_exit with a status
</span>  1167    <span class="xdoc">     *  code of 0.
</span>  1168    <span class="xdoc">     *
</span>  1169    <span class="xdoc">     *  Task_exit is automatically called whenever a task returns from its
</span>  1170    <span class="xdoc">     *  top-level function.
</span>  1171    <span class="xdoc">     *
</span>  1172    <span class="xdoc">     *  Exit Hooks (see exitFxn in {<b>@link</b> #HookSet}) can be used to provide
</span>  1173    <span class="xdoc">     *  functions that run whenever a task is terminated. The exitFxn Hooks
</span>  1174    <span class="xdoc">     *  are called before the task has been blocked and marked
</span>  1175    <span class="xdoc">     *  {<b>@link</b> #Mode_TERMINATED}.
</span>  1176    <span class="xdoc">     *  See {<b>@link</b> #hookfunc Hook Functions} for more information.
</span>  1177    <span class="xdoc">     *
</span>  1178    <span class="xdoc">     *  Any SYS/BIOS function can be called from an Exit Hook function.
</span>  1179    <span class="xdoc">     *
</span>  1180    <span class="xdoc">     *  Calling {<b>@link</b> #self} within an Exit function returns the task
</span>  1181    <span class="xdoc">     *  being exited. Your Exit function declaration should be similar to
</span>  1182    <span class="xdoc">     *  the following:
</span>  1183    <span class="xdoc">     *  <b>@p(code)</b>
</span>  1184    <span class="xdoc">     *  Void myExitFxn(Void);
</span>  1185    <span class="xdoc">     *  <b>@p</b>
</span>  1186    <span class="xdoc">     *
</span>  1187    <span class="xdoc">     *  A task switch occurs when calling Task_exit unless the program as a
</span>  1188    <span class="xdoc">     *  whole is terminated
</span>  1189    <span class="xdoc">     *
</span>  1190    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>  1191    <span class="xdoc">     *  Task_exit cannot be called from a Swi or Hwi.
</span>  1192    <span class="xdoc">     *
</span>  1193    <span class="xdoc">     *  Task_exit cannot be called from the program's main() function.
</span>  1194    <span class="xdoc">     */</span>
  1195        Void exit();
  1196    
  1197        <span class="xdoc">/*!
</span>  1198    <span class="xdoc">     *  ======== sleep ========
</span>  1199    <span class="xdoc">     *  Delay execution of the current task.
</span>  1200    <span class="xdoc">     *
</span>  1201    <span class="xdoc">     *  Task_sleep changes the current task's mode from {<b>@link</b> #Mode_RUNNING}
</span>  1202    <span class="xdoc">     *  to {<b>@link</b> #Mode_BLOCKED}, and delays its execution for nticks
</span>  1203    <span class="xdoc">     *  increments of the {<b>@link</b> Clock system clock}. The actual time
</span>  1204    <span class="xdoc">     *  delayed can be up to 1 system clock tick less than nticks due to
</span>  1205    <span class="xdoc">     *  granularity in system timekeeping and the time elapsed per
</span>  1206    <span class="xdoc">     *  tick is determined by {<b>@link</b> Clock#tickPeriod Clock_tickPeriod}.
</span>  1207    <span class="xdoc">     *
</span>  1208    <span class="xdoc">     *  After the specified period of time has elapsed, the task reverts to
</span>  1209    <span class="xdoc">     *  the {<b>@link</b> #Mode_READY} mode and is scheduled for execution.
</span>  1210    <span class="xdoc">     *
</span>  1211    <span class="xdoc">     *  A task switch always occurs when calling Task_sleep if nticks &gt; 0.
</span>  1212    <span class="xdoc">     *
</span>  1213    <span class="xdoc">     *  <b>@param(nticks)</b>  number of system clock ticks to sleep
</span>  1214    <span class="xdoc">     *
</span>  1215    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>  1216    <span class="xdoc">     *  Task_sleep cannot be called from a Swi or Hwi, or within a
</span>  1217    <span class="xdoc">     *  {<b>@link</b> #disable} / {<b>@link</b> #restore} block.
</span>  1218    <span class="xdoc">     *
</span>  1219    <span class="xdoc">     *  Task_sleep cannot be called from the program's main() function.
</span>  1220    <span class="xdoc">     *
</span>  1221    <span class="xdoc">     *  Task_sleep should not be called from within an Idle function. Doing
</span>  1222    <span class="xdoc">     *  so prevents analysis tools from gathering run-time information.
</span>  1223    <span class="xdoc">     *
</span>  1224    <span class="xdoc">     *  nticks cannot be {<b>@link</b> ti.sysbios.BIOS#WAIT_FOREVER BIOS_WAIT_FOREVER}.
</span>  1225    <span class="xdoc">     */</span>
  1226        Void sleep(UInt32 nticks);
  1227    
  1228        <span class="xdoc">/*!
</span>  1229    <span class="xdoc">     *  ======== yield ========
</span>  1230    <span class="xdoc">     *  Yield processor to equal priority task.
</span>  1231    <span class="xdoc">     *
</span>  1232    <span class="xdoc">     *  Task_yield yields the processor to another task of equal priority.
</span>  1233    <span class="xdoc">     *
</span>  1234    <span class="xdoc">     *  A task switch occurs when you call Task_yield if there is an equal
</span>  1235    <span class="xdoc">     *  priority task ready to run.
</span>  1236    <span class="xdoc">     *
</span>  1237    <span class="xdoc">     *  Tasks of higher priority preempt the currently running task without
</span>  1238    <span class="xdoc">     *  the need for a call to Task_yield. If only lower-priority tasks are
</span>  1239    <span class="xdoc">     *  ready to run when you call Task_yield, the current task continues to
</span>  1240    <span class="xdoc">     *  run. Control does not pass to a lower-priority task.
</span>  1241    <span class="xdoc">     *
</span>  1242    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>  1243    <span class="xdoc">     *  When called within an Hwi, the code sequence calling Task_yield
</span>  1244    <span class="xdoc">     *  must be invoked by the Hwi dispatcher.
</span>  1245    <span class="xdoc">     *
</span>  1246    <span class="xdoc">     *  Task_yield cannot be called from the program's main() function.
</span>  1247    <span class="xdoc">     */</span>
  1248        Void yield();
  1249    
  1250        <span class="xdoc">/*!
</span>  1251    <span class="xdoc">     *  ======== getIdleTask ========
</span>  1252    <span class="xdoc">     *  returns a handle to the idle task object (for core 0)
</span>  1253    <span class="xdoc">     */</span>
  1254        Handle getIdleTask();
  1255    
  1256        <span class="xdoc">/*!
</span>  1257    <span class="xdoc">     *  ======== getIdleTaskHandle ========
</span>  1258    <span class="xdoc">     *  returns a handle to the idle task object for the specified coreId
</span>  1259    <span class="xdoc">     *  (should be used only in applications built with
</span>  1260    <span class="xdoc">     *  {<b>@link</b> ti.sysbios.BIOS#smpEnabled} set to true)
</span>  1261    <span class="xdoc">     *
</span>  1262    <span class="xdoc">     *  <b>@a(Note)</b>
</span>  1263    <span class="xdoc">     *  If this function is called in a non-SMP application, coreId should
</span>  1264    <span class="xdoc">     *  always be 0.
</span>  1265    <span class="xdoc">     */</span>
  1266        Handle getIdleTaskHandle(UInt coreId);
  1267    
  1268        <span class="xdoc">/*!
</span>  1269    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1270    <span class="xdoc">     *  ======== startCore ========
</span>  1271    <span class="xdoc">     *  begin tasking on a core
</span>  1272    <span class="xdoc">     */</span>
  1273        Void startCore(UInt coreId);
  1274    
  1275        <span class="xdoc">/*!
</span>  1276    <span class="xdoc">     *  ======== getNickName ========
</span>  1277    <span class="xdoc">     *
</span>  1278    <span class="xdoc">     */</span>
  1279        <span class=key>metaonly</span> String getNickName(Any tskView);
  1280    
  1281    <span class=key>instance</span>:
  1282    
  1283        <span class="xdoc">/*!
</span>  1284    <span class="xdoc">     *  ======== create ========
</span>  1285    <span class="xdoc">     *  Create a Task.
</span>  1286    <span class="xdoc">     *
</span>  1287    <span class="xdoc">     *  Task_create creates a new task object. If successful, Task_create
</span>  1288    <span class="xdoc">     *  returns the handle of the new task object. If unsuccessful,
</span>  1289    <span class="xdoc">     *  Task_create returns NULL unless it aborts.
</span>  1290    <span class="xdoc">     *
</span>  1291    <span class="xdoc">     *  The fxn parameter uses the {<b>@link</b> #FuncPtr} type to pass a pointer to
</span>  1292    <span class="xdoc">     *  the function the Task object should run. For example, if myFxn is a
</span>  1293    <span class="xdoc">     *  function in your program, your C code can create a Task object
</span>  1294    <span class="xdoc">     *  to call that
</span>  1295    <span class="xdoc">     *  function as follows:
</span>  1296    <span class="xdoc">     *
</span>  1297    <span class="xdoc">     *  <b>@p(code)</b>
</span>  1298    <span class="xdoc">     *  Task_Params taskParams;
</span>  1299    <span class="xdoc">     *
</span>  1300    <span class="xdoc">     *  // Create task with priority 15
</span>  1301    <span class="xdoc">     *  Task_Params_init(&amp;taskParams);
</span>  1302    <span class="xdoc">     *  taskParams.stackSize = 512;
</span>  1303    <span class="xdoc">     *  taskParams.priority = 15;
</span>  1304    <span class="xdoc">     *  Task_create((Task_FuncPtr)myFxn, &amp;taskParams, &amp;eb);
</span>  1305    <span class="xdoc">     *  <b>@p</b>
</span>  1306    <span class="xdoc">     *
</span>  1307    <span class="xdoc">     *  The following statements statically create a task in the
</span>  1308    <span class="xdoc">     *  configuration file:
</span>  1309    <span class="xdoc">     *
</span>  1310    <span class="xdoc">     *  <b>@p(code)</b>
</span>  1311    <span class="xdoc">     *  var params = new Task.Params;
</span>  1312    <span class="xdoc">     *  params.instance.name = "tsk0";
</span>  1313    <span class="xdoc">     *  params.arg0 = 1;
</span>  1314    <span class="xdoc">     *  params.arg1 = 2;
</span>  1315    <span class="xdoc">     *  params.priority = 1;
</span>  1316    <span class="xdoc">     *  Task.create('&amp;tsk0_func', params);
</span>  1317    <span class="xdoc">     *  <b>@p</b>
</span>  1318    <span class="xdoc">     *
</span>  1319    <span class="xdoc">     *  If NULL is passed instead of a pointer to an actual Task_Params
</span>  1320    <span class="xdoc">     *  struct, a
</span>  1321    <span class="xdoc">     *  default set of parameters is used. The "eb" is an error block that
</span>  1322    <span class="xdoc">     *  you can use
</span>  1323    <span class="xdoc">     *  to handle errors that may occur during Task object creation.
</span>  1324    <span class="xdoc">     *
</span>  1325    <span class="xdoc">     *  The newly created task is placed in {<b>@link</b> #Mode_READY} mode, and is
</span>  1326    <span class="xdoc">     *  scheduled to begin concurrent execution of the following function
</span>  1327    <span class="xdoc">     *  call:
</span>  1328    <span class="xdoc">     *
</span>  1329    <span class="xdoc">     *  <b>@p(code)</b>
</span>  1330    <span class="xdoc">     *  (*fxn)(arg1, arg2);
</span>  1331    <span class="xdoc">     *  <b>@p</b>
</span>  1332    <span class="xdoc">     *
</span>  1333    <span class="xdoc">     *  As a result of being made ready to run, the task runs any
</span>  1334    <span class="xdoc">     *  application-wide Ready functions that have been specified.
</span>  1335    <span class="xdoc">     *
</span>  1336    <span class="xdoc">     *  Task_exit is automatically called if and when the task returns
</span>  1337    <span class="xdoc">     *  from fxn.
</span>  1338    <span class="xdoc">     *
</span>  1339    <span class="xdoc">     *  <b>@p(html)</b>
</span>  1340    <span class="xdoc">     *  &lt;B&gt;Create Hook Functions&lt;/B&gt;
</span>  1341    <span class="xdoc">     *  <b>@p</b>
</span>  1342    <span class="xdoc">     *
</span>  1343    <span class="xdoc">     *  You can specify application-wide Create hook functions in your config
</span>  1344    <span class="xdoc">     *  file that run whenever a task is created. This includes tasks that
</span>  1345    <span class="xdoc">     *  are created statically and those created dynamically using
</span>  1346    <span class="xdoc">     *  Task_create.
</span>  1347    <span class="xdoc">     *
</span>  1348    <span class="xdoc">     *  For Task objects created statically, Create functions are called
</span>  1349    <span class="xdoc">     *  during the Task module initialization phase of the program startup
</span>  1350    <span class="xdoc">     *  process prior to main().
</span>  1351    <span class="xdoc">     *
</span>  1352    <span class="xdoc">     *  For Task objects created dynamically, Create functions
</span>  1353    <span class="xdoc">     *  are called after the task handle has been initialized but before the
</span>  1354    <span class="xdoc">     *  task has been placed on its ready queue.
</span>  1355    <span class="xdoc">     *
</span>  1356    <span class="xdoc">     *  Any SYS/BIOS function can be called from Create functions.
</span>  1357    <span class="xdoc">     *  SYS/BIOS passes the task handle of the task being created to each of
</span>  1358    <span class="xdoc">     *  the Create functions.
</span>  1359    <span class="xdoc">     *
</span>  1360    <span class="xdoc">     *  All Create function declarations should be similar to this:
</span>  1361    <span class="xdoc">     *  <b>@p(code)</b>
</span>  1362    <span class="xdoc">     *  Void myCreateFxn(Task_Handle task);
</span>  1363    <span class="xdoc">     *  <b>@p</b>
</span>  1364    <span class="xdoc">     *
</span>  1365    <span class="xdoc">     *  <b>@param(fxn)</b>     Task Function
</span>  1366    <span class="xdoc">     *
</span>  1367    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>  1368    <span class="xdoc">     *  <b>@p(blist)</b>
</span>  1369    <span class="xdoc">     *  - The fxn parameter and the name attribute cannot be NULL.
</span>  1370    <span class="xdoc">     *  - The priority attribute must be less than or equal to
</span>  1371    <span class="xdoc">     *  ({<b>@link</b> #numPriorities} - 1) and greater than or equal to one (1)
</span>  1372    <span class="xdoc">     *  (priority 0 is owned by the Idle task).
</span>  1373    <span class="xdoc">     *  - The priority can be set to -1 for tasks that will not execute
</span>  1374    <span class="xdoc">     *  until another task changes the priority to a positive value.
</span>  1375    <span class="xdoc">     *  - The stackHeap attribute must identify a valid memory Heap.
</span>  1376    <span class="xdoc">     *  <b>@p</b>
</span>  1377    <span class="xdoc">     */</span>
  1378        create(FuncPtr fxn);
  1379    
  1380        <span class=comment>// -------- Handle Parameters --------</span>
  1381    
  1382        <span class="xdoc">/*! Task function argument. Default is 0 */</span>
  1383        <span class=key>config</span> UArg arg0 = 0;
  1384    
  1385        <span class="xdoc">/*! Task function argument. Default is 0 */</span>
  1386        <span class=key>config</span> UArg arg1 = 0;
  1387    
  1388        <span class="xdoc">/*!
</span>  1389    <span class="xdoc">     *  Task priority (0 to Task.numPriorities-1, or -1).
</span>  1390    <span class="xdoc">     *  Default is 1.
</span>  1391    <span class="xdoc">     */</span>
  1392        <span class=key>config</span> Int priority = 1;
  1393    
  1394        <span class="xdoc">/*!
</span>  1395    <span class="xdoc">     *  Task stack pointer. Default = null.
</span>  1396    <span class="xdoc">     *
</span>  1397    <span class="xdoc">     *  Null indicates that the stack is to be allocated by create().
</span>  1398    <span class="xdoc">     *
</span>  1399    <span class="xdoc">     *  Example: To statically initialize "tsk0"'s stack to a literal
</span>  1400    <span class="xdoc">     *  address, use the following syntax:
</span>  1401    <span class="xdoc">     *
</span>  1402    <span class="xdoc">     *  <b>@p(code)</b>
</span>  1403    <span class="xdoc">     *      Program.global.tsk0.stack = $addr(literal);
</span>  1404    <span class="xdoc">     *  <b>@p</b>
</span>  1405    <span class="xdoc">     *
</span>  1406    <span class="xdoc">     */</span>
  1407        <span class=key>config</span> Ptr stack = <span class=key>null</span>;
  1408    
  1409        <span class="xdoc">/*!
</span>  1410    <span class="xdoc">     *  Task stack size in MAUs.
</span>  1411    <span class="xdoc">     *
</span>  1412    <span class="xdoc">     *  The default value of 0 means that the module config
</span>  1413    <span class="xdoc">     *  {<b>@link</b> #defaultStackSize} is used.
</span>  1414    <span class="xdoc">     */</span>
  1415        <span class=key>config</span> SizeT stackSize = 0;
  1416    
  1417        <span class="xdoc">/*!
</span>  1418    <span class="xdoc">     *  Mem section used for statically created task stacks.
</span>  1419    <span class="xdoc">     *
</span>  1420    <span class="xdoc">     *  Default is inherited from module config defaultStackSection.
</span>  1421    <span class="xdoc">     */</span>
  1422        <span class=key>metaonly</span> <span class=key>config</span> String stackSection;
  1423    
  1424        <span class="xdoc">/*!
</span>  1425    <span class="xdoc">     *  Mem heap used for dynamically created task stack.
</span>  1426    <span class="xdoc">     *
</span>  1427    <span class="xdoc">     *  The default value of NULL means that the module config
</span>  1428    <span class="xdoc">     *  {<b>@link</b> #defaultStackHeap} is used.
</span>  1429    <span class="xdoc">     */</span>
  1430        <span class=key>config</span> IHeap.Handle stackHeap = <span class=key>null</span>;
  1431    
  1432        <span class="xdoc">/*! Environment data struct. */</span>
  1433        <span class=key>config</span> Ptr env = <span class=key>null</span>;
  1434    
  1435        <span class="xdoc">/*!
</span>  1436    <span class="xdoc">     *  Exit system immediately when the last task with this
</span>  1437    <span class="xdoc">     *  flag set to TRUE has terminated.
</span>  1438    <span class="xdoc">     *
</span>  1439    <span class="xdoc">     *  Default is true.
</span>  1440    <span class="xdoc">     */</span>
  1441        <span class=key>config</span> Bool vitalTaskFlag = <span class=key>true</span>;
  1442    
  1443        <span class="xdoc">/*!
</span>  1444    <span class="xdoc">     *  The core which this task is to run on. Default is Task_AFFINITY_NONE
</span>  1445    <span class="xdoc">     *
</span>  1446    <span class="xdoc">     *  If there is a compelling reason for a task to be pinned to a
</span>  1447    <span class="xdoc">     *  particular core, then setting 'affinity' to the corresponding core
</span>  1448    <span class="xdoc">     *  id will force the task to only be run on that core.
</span>  1449    <span class="xdoc">     *
</span>  1450    <span class="xdoc">     *  The default affinity is inherited from {<b>@link</b> #defaultAffinity
</span>  1451    <span class="xdoc">     *  Task.defaultAffinity}
</span>  1452    <span class="xdoc">     *  which in turn defaults to {<b>@link</b> #AFFINITY_NONE Task_AFFINITY_NONE},
</span>  1453    <span class="xdoc">     *  which means the task can be run on either core.
</span>  1454    <span class="xdoc">     *
</span>  1455    <span class="xdoc">     *  Furthermore,  Task_AFFINITY_NONE implies that the task can be moved
</span>  1456    <span class="xdoc">     *  from core to core as deemed necessary by the Task scheduler in order
</span>  1457    <span class="xdoc">     *  to keep the two highest priority ready tasks running simultaneously.
</span>  1458    <span class="xdoc">     */</span>
  1459        <span class=key>config</span> UInt affinity;
  1460    
  1461        <span class=comment>// -------- Handle Functions --------</span>
  1462    
  1463        <span class="xdoc">/*!
</span>  1464    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1465    <span class="xdoc">     *  ======== getArg0 ========
</span>  1466    <span class="xdoc">     *  Returns arg0 passed via params to create.
</span>  1467    <span class="xdoc">     *
</span>  1468    <span class="xdoc">     *  <b>@b(returns)</b>     task's arg0
</span>  1469    <span class="xdoc">     */</span>
  1470        UArg getArg0();
  1471    
  1472        <span class="xdoc">/*!
</span>  1473    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1474    <span class="xdoc">     *  ======== getArg1 ========
</span>  1475    <span class="xdoc">     *  Returns arg1 passed via params to create.
</span>  1476    <span class="xdoc">     *
</span>  1477    <span class="xdoc">     *  <b>@b(returns)</b>     task's arg1
</span>  1478    <span class="xdoc">     */</span>
  1479        UArg getArg1();
  1480    
  1481        <span class="xdoc">/*!
</span>  1482    <span class="xdoc">     *  ======== getEnv ========
</span>  1483    <span class="xdoc">     *  Get task environment pointer.
</span>  1484    <span class="xdoc">     *
</span>  1485    <span class="xdoc">     *  Task_getEnv returns the environment pointer of the specified task. The
</span>  1486    <span class="xdoc">     *  environment pointer references an arbitrary application-defined data
</span>  1487    <span class="xdoc">     *  structure.
</span>  1488    <span class="xdoc">     *
</span>  1489    <span class="xdoc">     *  If your program uses multiple hook sets, {<b>@link</b> #getHookContext}
</span>  1490    <span class="xdoc">     *  allows you to get environment pointers you have set for a particular
</span>  1491    <span class="xdoc">     *  hook set and Task object combination.
</span>  1492    <span class="xdoc">     *
</span>  1493    <span class="xdoc">     *  <b>@b(returns)</b>     task environment pointer
</span>  1494    <span class="xdoc">     */</span>
  1495        Ptr getEnv();
  1496    
  1497        <span class="xdoc">/*!
</span>  1498    <span class="xdoc">     *  ======== getFunc ========
</span>  1499    <span class="xdoc">     *  Get Task function and arguments
</span>  1500    <span class="xdoc">     *
</span>  1501    <span class="xdoc">     *  If either arg0 or arg1 is NULL, then the corresponding argument is not
</span>  1502    <span class="xdoc">     *  returned.
</span>  1503    <span class="xdoc">     *
</span>  1504    <span class="xdoc">     *  <b>@param(arg0)</b>    pointer for returning Task's first function argument
</span>  1505    <span class="xdoc">     *  <b>@param(arg1)</b>    pointer for returning Task's second function argument
</span>  1506    <span class="xdoc">     *
</span>  1507    <span class="xdoc">     *  <b>@b(returns)</b>     Task function
</span>  1508    <span class="xdoc">     */</span>
  1509        FuncPtr getFunc(UArg *arg0, UArg *arg1);
  1510    
  1511        <span class="xdoc">/*!
</span>  1512    <span class="xdoc">     *  ======== getHookContext ========
</span>  1513    <span class="xdoc">     *  Get hook set's context for a task.
</span>  1514    <span class="xdoc">     *
</span>  1515    <span class="xdoc">     *  For example, this C code gets the HookContext, prints it,
</span>  1516    <span class="xdoc">     *  and sets a new value for the HookContext.
</span>  1517    <span class="xdoc">     *
</span>  1518    <span class="xdoc">     *  <b>@p(code)</b>
</span>  1519    <span class="xdoc">     *  Ptr pEnv;
</span>  1520    <span class="xdoc">     *  Task_Handle myTask;
</span>  1521    <span class="xdoc">     *  Int myHookSetId1;
</span>  1522    <span class="xdoc">     *
</span>  1523    <span class="xdoc">     *  pEnv = Task_getHookContext(task, myHookSetId1);
</span>  1524    <span class="xdoc">     *
</span>  1525    <span class="xdoc">     *  System_printf("myEnd1: pEnv = 0x%lx, time = %ld\n",
</span>  1526    <span class="xdoc">     *                (ULong)pEnv, (ULong)Timestamp_get32());
</span>  1527    <span class="xdoc">     *
</span>  1528    <span class="xdoc">     *  Task_setHookContext(task, myHookSetId1, (Ptr)0xc0de1);
</span>  1529    <span class="xdoc">     *  <b>@p</b>
</span>  1530    <span class="xdoc">     *
</span>  1531    <span class="xdoc">     *  See {<b>@link</b> #hookfunc Hook Functions} for more details.
</span>  1532    <span class="xdoc">     *
</span>  1533    <span class="xdoc">     *  <b>@param(id)</b>      hook set ID
</span>  1534    <span class="xdoc">     *  <b>@b(returns)</b>     hook set context for task
</span>  1535    <span class="xdoc">     */</span>
  1536        Ptr getHookContext(Int id);
  1537    
  1538        <span class="xdoc">/*!
</span>  1539    <span class="xdoc">     *  ======== getPri ========
</span>  1540    <span class="xdoc">     *  Get task priority.
</span>  1541    <span class="xdoc">     *
</span>  1542    <span class="xdoc">     *  Task_getPri returns the priority of the referenced task.
</span>  1543    <span class="xdoc">     *
</span>  1544    <span class="xdoc">     *  <b>@b(returns)</b>     task priority
</span>  1545    <span class="xdoc">     */</span>
  1546        Int getPri();
  1547    
  1548        <span class="xdoc">/*!
</span>  1549    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1550    <span class="xdoc">     *  ======== setArg0 ========
</span>  1551    <span class="xdoc">     *  Set arg0 (used primarily for legacy support)
</span>  1552    <span class="xdoc">     */</span>
  1553        Void setArg0(UArg arg);
  1554    
  1555        <span class="xdoc">/*!
</span>  1556    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1557    <span class="xdoc">     *  ======== setArg1 ========
</span>  1558    <span class="xdoc">     *  Set arg1 (used primarily for legacy support)
</span>  1559    <span class="xdoc">     */</span>
  1560        Void setArg1(UArg arg);
  1561    
  1562        <span class="xdoc">/*!
</span>  1563    <span class="xdoc">     *  ======== setEnv ========
</span>  1564    <span class="xdoc">     *  Set task environment.
</span>  1565    <span class="xdoc">     *
</span>  1566    <span class="xdoc">     *  Task_setEnv sets the task environment pointer to env. The
</span>  1567    <span class="xdoc">     *  environment pointer references an arbitrary application-defined
</span>  1568    <span class="xdoc">     *  data structure.
</span>  1569    <span class="xdoc">     *
</span>  1570    <span class="xdoc">     *  If your program uses multiple hook sets, {<b>@link</b> #setHookContext}
</span>  1571    <span class="xdoc">     *  allows you to set environment pointers for any
</span>  1572    <span class="xdoc">     *  hook set and Task object combination.
</span>  1573    <span class="xdoc">     *
</span>  1574    <span class="xdoc">     *  <b>@param(env)</b>     task environment pointer
</span>  1575    <span class="xdoc">     */</span>
  1576        Void setEnv(Ptr env);
  1577    
  1578        <span class="xdoc">/*!
</span>  1579    <span class="xdoc">     *  ======== setHookContext ========
</span>  1580    <span class="xdoc">     *  Set hook instance's context for a task.
</span>  1581    <span class="xdoc">     *
</span>  1582    <span class="xdoc">     *  For example, this C code gets the HookContext, prints it,
</span>  1583    <span class="xdoc">     *  and sets a new value for the HookContext.
</span>  1584    <span class="xdoc">     *
</span>  1585    <span class="xdoc">     *  <b>@p(code)</b>
</span>  1586    <span class="xdoc">     *  Ptr pEnv;
</span>  1587    <span class="xdoc">     *  Task_Handle myTask;
</span>  1588    <span class="xdoc">     *  Int myHookSetId1;
</span>  1589    <span class="xdoc">     *
</span>  1590    <span class="xdoc">     *  pEnv = Task_getHookContext(task, myHookSetId1);
</span>  1591    <span class="xdoc">     *
</span>  1592    <span class="xdoc">     *  System_printf("myEnd1: pEnv = 0x%lx, time = %ld\n",
</span>  1593    <span class="xdoc">     *                (ULong)pEnv, (ULong)Timestamp_get32());
</span>  1594    <span class="xdoc">     *
</span>  1595    <span class="xdoc">     *  Task_setHookContext(task, myHookSetId1, (Ptr)0xc0de1);
</span>  1596    <span class="xdoc">     *  <b>@p</b>
</span>  1597    <span class="xdoc">     *
</span>  1598    <span class="xdoc">     *  See {<b>@link</b> #hookfunc Hook Functions} for more details.
</span>  1599    <span class="xdoc">     *
</span>  1600    <span class="xdoc">     *  <b>@param(id)</b>              hook set ID
</span>  1601    <span class="xdoc">     *  <b>@param(hookContext)</b>     value to write to context
</span>  1602    <span class="xdoc">     */</span>
  1603        Void setHookContext(Int id, Ptr hookContext);
  1604    
  1605        <span class="xdoc">/*!
</span>  1606    <span class="xdoc">     *  ======== setPri ========
</span>  1607    <span class="xdoc">     *  Set a task's priority
</span>  1608    <span class="xdoc">     *
</span>  1609    <span class="xdoc">     *  Task_setpri sets the execution priority of task to newpri, and returns
</span>  1610    <span class="xdoc">     *  that task's old priority value. Raising or lowering a task's priority
</span>  1611    <span class="xdoc">     *  does not necessarily force preemption and re-scheduling of the caller:
</span>  1612    <span class="xdoc">     *  tasks in the {<b>@link</b> #Mode_BLOCKED} mode remain suspended despite a
</span>  1613    <span class="xdoc">     *  change in priority; and tasks in the {<b>@link</b> #Mode_READY} mode gain
</span>  1614    <span class="xdoc">     *  control only if their new priority is greater than that of the
</span>  1615    <span class="xdoc">     *  currently executing task.
</span>  1616    <span class="xdoc">     *
</span>  1617    <span class="xdoc">     *  newpri should be set to a value greater than or equal to 1 and
</span>  1618    <span class="xdoc">     *  less than or equal to ({<b>@link</b> #numPriorities} - 1).  newpri can also
</span>  1619    <span class="xdoc">     *  be set to -1 which puts the the task into the INACTIVE state and the
</span>  1620    <span class="xdoc">     *  task will not run until its priority is raised at a later time by
</span>  1621    <span class="xdoc">     *  another task.  Priority 0 is reserved for the idle task.
</span>  1622    <span class="xdoc">     *  If newpri equals ({<b>@link</b> #numPriorities} - 1), execution of the task
</span>  1623    <span class="xdoc">     *  effectively locks out all other program activity, except for the
</span>  1624    <span class="xdoc">     *  handling of interrupts.
</span>  1625    <span class="xdoc">     *
</span>  1626    <span class="xdoc">     *  The current task can change its own priority (and possibly preempt its
</span>  1627    <span class="xdoc">     *  execution) by passing the output of {<b>@link</b> #self} as the value of the
</span>  1628    <span class="xdoc">     *  task parameter.
</span>  1629    <span class="xdoc">     *
</span>  1630    <span class="xdoc">     *  A context switch occurs when calling Task_setpri if a currently
</span>  1631    <span class="xdoc">     *  running task priority is set lower than the priority of another
</span>  1632    <span class="xdoc">     *  currently ready task, or if another ready task is made to have a
</span>  1633    <span class="xdoc">     *  higher priority than the currently running task.
</span>  1634    <span class="xdoc">     *
</span>  1635    <span class="xdoc">     *  Task_setpri can be used for mutual exclusion.
</span>  1636    <span class="xdoc">     *
</span>  1637    <span class="xdoc">     *  If a task's new priority is different than its previous priority,
</span>  1638    <span class="xdoc">     *  then its relative placement in its new ready task priority
</span>  1639    <span class="xdoc">     *  queue can be different than the one it was removed from. This can
</span>  1640    <span class="xdoc">     *  effect the relative order in which it becomes the running task.
</span>  1641    <span class="xdoc">     *
</span>  1642    <span class="xdoc">     *  The effected task is placed at the head of its new priority queue
</span>  1643    <span class="xdoc">     *  if it is the currently running task. Otherwise it is placed at
</span>  1644    <span class="xdoc">     *  at the end of its new task priority queue.
</span>  1645    <span class="xdoc">     *
</span>  1646    <span class="xdoc">     *  <b>@param(newpri)</b> task's new priority
</span>  1647    <span class="xdoc">     *  <b>@b(returns)</b>     task's old priority
</span>  1648    <span class="xdoc">     *
</span>  1649    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>  1650    <span class="xdoc">     *  newpri must be a value between 1 and ({<b>@link</b> #numPriorities} - 1) or -1.
</span>  1651    <span class="xdoc">     *
</span>  1652    <span class="xdoc">     *  The task cannot be in the {<b>@link</b> #Mode_TERMINATED} mode.
</span>  1653    <span class="xdoc">     *
</span>  1654    <span class="xdoc">     *  The new priority should not be zero (0). This priority level is
</span>  1655    <span class="xdoc">     *  reserved for the Idle task.
</span>  1656    <span class="xdoc">     */</span>
  1657        UInt setPri(Int newpri);
  1658    
  1659        <span class="xdoc">/*!
</span>  1660    <span class="xdoc">     *  ======== stat ========
</span>  1661    <span class="xdoc">     *  Retrieve the status of a task.
</span>  1662    <span class="xdoc">     *
</span>  1663    <span class="xdoc">     *  Task_stat retrieves attribute values and status information about a
</span>  1664    <span class="xdoc">     *  task.
</span>  1665    <span class="xdoc">     *
</span>  1666    <span class="xdoc">     *  Status information is returned through statbuf, which references a
</span>  1667    <span class="xdoc">     *  structure of type {<b>@link</b> #Stat}.
</span>  1668    <span class="xdoc">     *
</span>  1669    <span class="xdoc">     *  When a task is preempted by a software or hardware interrupt, the task
</span>  1670    <span class="xdoc">     *  execution mode returned for that task by Task_stat is still
</span>  1671    <span class="xdoc">     *  {<b>@link</b> #Mode_RUNNING}  because the task runs when the preemption ends.
</span>  1672    <span class="xdoc">     *
</span>  1673    <span class="xdoc">     *  The current task can inquire about itself by passing the output of
</span>  1674    <span class="xdoc">     *  {<b>@link</b> #self} as the first argument to Task_stat. However, the task
</span>  1675    <span class="xdoc">     *  stack pointer (sp) in the {<b>@link</b> #Stat} structure is the value from
</span>  1676    <span class="xdoc">     *  the previous context switch.
</span>  1677    <span class="xdoc">     *
</span>  1678    <span class="xdoc">     *  Task_stat has a non-deterministic execution time. As such, it is not
</span>  1679    <span class="xdoc">     *  recommended to call this API from Swis or Hwis.
</span>  1680    <span class="xdoc">     *
</span>  1681    <span class="xdoc">     *  <b>@param(statbuf)</b> pointer to task status structure
</span>  1682    <span class="xdoc">     *
</span>  1683    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>  1684    <span class="xdoc">     *  statbuf cannot be NULL;
</span>  1685    <span class="xdoc">     */</span>
  1686        Void stat(Stat *statbuf);
  1687    
  1688        <span class="xdoc">/*!
</span>  1689    <span class="xdoc">     *  ======== getMode ========
</span>  1690    <span class="xdoc">     *  Retrieve the {<b>@link</b> #Mode} of a task.
</span>  1691    <span class="xdoc">     */</span>
  1692        Mode getMode();
  1693    
  1694        <span class="xdoc">/*!
</span>  1695    <span class="xdoc">     *  ======== setAffinity ========
</span>  1696    <span class="xdoc">     *  Set task's core affinity (should be used only in applications built
</span>  1697    <span class="xdoc">     *  with {<b>@link</b> ti.sysbios.BIOS#smpEnabled} set to true)
</span>  1698    <span class="xdoc">     *
</span>  1699    <span class="xdoc">     *  If the new core ID is different than the current core affinity
</span>  1700    <span class="xdoc">     *  a reschedule will be performed immediately.
</span>  1701    <span class="xdoc">     *
</span>  1702    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>  1703    <span class="xdoc">     *  Must NOT be called with interrupts disabled
</span>  1704    <span class="xdoc">     *  (ie within a Hwi_disable()/Hwi_restore() block).
</span>  1705    <span class="xdoc">     *
</span>  1706    <span class="xdoc">     *  Must NOT be called with tasking disabled
</span>  1707    <span class="xdoc">     *  (ie within a Task_disable()/Task_restore() block).
</span>  1708    <span class="xdoc">     *
</span>  1709    <span class="xdoc">     *  <b>@b(returns)</b>     task's previous core affinity
</span>  1710    <span class="xdoc">     */</span>
  1711        UInt setAffinity(UInt coreId);
  1712    
  1713        <span class="xdoc">/*!
</span>  1714    <span class="xdoc">     *  ======== getAffinity ========
</span>  1715    <span class="xdoc">     *  Return task's core affinity (should be used only in applications built
</span>  1716    <span class="xdoc">     *  with {<b>@link</b> ti.sysbios.BIOS#smpEnabled} set to true)
</span>  1717    <span class="xdoc">     *
</span>  1718    <span class="xdoc">     *  <b>@b(returns)</b>     task's current core affinity
</span>  1719    <span class="xdoc">     */</span>
  1720        UInt getAffinity();
  1721    
  1722        <span class="xdoc">/*!
</span>  1723    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1724    <span class="xdoc">     *  ======== block ========
</span>  1725    <span class="xdoc">     *  Block a task.
</span>  1726    <span class="xdoc">     *
</span>  1727    <span class="xdoc">     *  Remove a task from its ready list.
</span>  1728    <span class="xdoc">     *  The effect of this API is manifest the next time the internal
</span>  1729    <span class="xdoc">     *  Task scheduler is invoked.
</span>  1730    <span class="xdoc">     *  This can be done directly by embedding the call within a
</span>  1731    <span class="xdoc">     *  {<b>@link</b> #disable}/{<b>@link</b> #restore} block.
</span>  1732    <span class="xdoc">     *  Otherwise, the effect will be manifest as a result of processing
</span>  1733    <span class="xdoc">     *  the next dispatched interrupt, or by posting a Swi, or by falling
</span>  1734    <span class="xdoc">     *  through the task function.
</span>  1735    <span class="xdoc">     *
</span>  1736    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>  1737    <span class="xdoc">     *  If called from within a Hwi or a Swi, or main(), there is no need
</span>  1738    <span class="xdoc">     *  to embed the call within a {<b>@link</b> #disable}/{<b>@link</b> #restore} block.
</span>  1739    <span class="xdoc">     */</span>
  1740        Void block();
  1741    
  1742        <span class="xdoc">/*!
</span>  1743    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1744    <span class="xdoc">     *  ======== unblock ========
</span>  1745    <span class="xdoc">     *  Unblock a task.
</span>  1746    <span class="xdoc">     *
</span>  1747    <span class="xdoc">     *  Place task in its ready list.
</span>  1748    <span class="xdoc">     *  The effect of this API is manifest the next time the internal
</span>  1749    <span class="xdoc">     *  Task scheduler is invoked.
</span>  1750    <span class="xdoc">     *  This can be done directly by embedding the call within a
</span>  1751    <span class="xdoc">     *  {<b>@link</b> #disable}/{<b>@link</b> #restore} block.
</span>  1752    <span class="xdoc">     *  Otherwise, the effect will be manifest as a result of processing
</span>  1753    <span class="xdoc">     *  the next dispatched interrupt, or by posting a Swi, or by falling
</span>  1754    <span class="xdoc">     *  through the task function.
</span>  1755    <span class="xdoc">     *
</span>  1756    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>  1757    <span class="xdoc">     *  If called from within a Hwi or a Swi, or main(), there is no need
</span>  1758    <span class="xdoc">     *  to embed the call within a {<b>@link</b> #disable}/{<b>@link</b> #restore} block.
</span>  1759    <span class="xdoc">     */</span>
  1760        Void unblock();
  1761    
  1762        <span class="xdoc">/*!
</span>  1763    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1764    <span class="xdoc">     *  ======== blockI ========
</span>  1765    <span class="xdoc">     *  Block a task.
</span>  1766    <span class="xdoc">     *
</span>  1767    <span class="xdoc">     *  Remove a task from its ready list.
</span>  1768    <span class="xdoc">     *  Must be called within Task_disable/Task_restore block
</span>  1769    <span class="xdoc">     *  with interrupts disabled.
</span>  1770    <span class="xdoc">     *  This API is meant to be used internally.
</span>  1771    <span class="xdoc">     */</span>
  1772        Void blockI();
  1773    
  1774        <span class="xdoc">/*!
</span>  1775    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1776    <span class="xdoc">     *  ======== unblockI ========
</span>  1777    <span class="xdoc">     *  Unblock a task.
</span>  1778    <span class="xdoc">     *
</span>  1779    <span class="xdoc">     *  Place task in its ready list.
</span>  1780    <span class="xdoc">     *  Must be called within Task_disable/Task_restore block
</span>  1781    <span class="xdoc">     *  with interrupts disabled.
</span>  1782    <span class="xdoc">     *  This API is meant to be used internally.
</span>  1783    <span class="xdoc">     *
</span>  1784    <span class="xdoc">     *  <b>@param(hwiKey)</b> key returned from Hwi_disable()
</span>  1785    <span class="xdoc">     */</span>
  1786        Void unblockI(UInt hwiKey);
  1787    
  1788    <span class=key>internal</span>:   <span class="comment">/* not for client use */</span>
  1789    
  1790        <span class="xdoc">/*! Target-specific support functions. */</span>
  1791        <span class=key>proxy</span> SupportProxy <span class=key>inherits</span> ti.sysbios.interfaces.ITaskSupport;
  1792    
  1793        <span class="comment">/*
</span>  1794    <span class="comment">     *  ======== schedule ========
</span>  1795    <span class="comment">     *  Find highest priority ready task and invoke it.
</span>  1796    <span class="comment">     *
</span>  1797    <span class="comment">     *  Must be called with interrupts disabled.
</span>  1798    <span class="comment">     */</span>
  1799        Void schedule();
  1800    
  1801        <span class="comment">/*
</span>  1802    <span class="comment">     *  ======== enter ========
</span>  1803    <span class="comment">     *  Task's initial entry point before entering task function.
</span>  1804    <span class="comment">     */</span>
  1805        Void enter();
  1806    
  1807        <span class="comment">/*
</span>  1808    <span class="comment">     *  ======== sleepTimeout ========
</span>  1809    <span class="comment">     *  This function is the clock event handler for sleep.
</span>  1810    <span class="comment">     */</span>
  1811        Void sleepTimeout(UArg arg);
  1812    
  1813        <span class="comment">/*
</span>  1814    <span class="comment">     *  ======== postInit ========
</span>  1815    <span class="comment">     *  finish initializing static and dynamic Tasks
</span>  1816    <span class="comment">     */</span>
  1817        Int postInit(Object *task, Error.Block *eb);
  1818    
  1819        <span class="comment">/*
</span>  1820    <span class="comment">     *  Number of statically constructed Task objects.
</span>  1821    <span class="comment">     *  Shouldn't be set directly by the user's
</span>  1822    <span class="comment">     *  config (it gets set by instance$static$init).
</span>  1823    <span class="comment">     */</span>
  1824        <span class=key>config</span> UInt numConstructedTasks = 0;
  1825    
  1826        <span class="comment">/*
</span>  1827    <span class="comment">     *  ======== allBlockedFunction ========
</span>  1828    <span class="comment">     *  default function to be called
</span>  1829    <span class="comment">     */</span>
  1830        Void allBlockedFunction();
  1831    
  1832        <span class="comment">/*
</span>  1833    <span class="comment">     *  ======== deleteTerminatedTasksFunc ========
</span>  1834    <span class="comment">     *  Idle func that deletes the first terminated task it finds
</span>  1835    <span class="comment">     *  in the queue of dynamically created tasks
</span>  1836    <span class="comment">     */</span>
  1837        Void deleteTerminatedTasksFunc();
  1838    
  1839        <span class="comment">/*
</span>  1840    <span class="comment">     *  ======== Task_processVitalTasks ========
</span>  1841    <span class="comment">     *  Call BIOS_exit() when last vitalTask exits or is
</span>  1842    <span class="comment">     *  deleted.
</span>  1843    <span class="comment">     */</span>
  1844        Void processVitalTaskFlag(Object *task);
  1845    
  1846        <span class="comment">/*
</span>  1847    <span class="comment">     *  ======== startupHookFunc ========
</span>  1848    <span class="comment">     *  Called by core 0 just before switch to first task
</span>  1849    <span class="comment">     */</span>
  1850        <span class=key>config</span> Void (*startupHookFunc)(Void) = <span class=key>null</span>;
  1851    
  1852        <span class="comment">/*
</span>  1853    <span class="comment">     *  Common object used by all blocked tasks to enable Task_delete()
</span>  1854    <span class="comment">     *  to remove a task from any pend Q it is placed on while blocked.
</span>  1855    <span class="comment">     */</span>
  1856        <span class=key>struct</span> PendElem {
  1857            Queue.Elem      qElem;
  1858            Task.Handle     task;
  1859            Clock.Handle    clock;
  1860        };
  1861    
  1862        <span class=key>struct</span> Instance_State {
  1863            Queue.Elem      qElem;          <span class=comment>// Task's readyQ element</span>
  1864            volatile Int    priority;       <span class=comment>// Task priority</span>
  1865            UInt            mask;           <span class=comment>// curSet mask = 1 &lt;&lt; priority</span>
  1866            Ptr             context;        <span class=comment>// ptr to Task's saved context</span>
  1867                                            <span class=comment>// while not in RUNNING mode.</span>
  1868            Mode            mode;           <span class=comment>// READY, BLOCKED, RUNNING, etc</span>
  1869            PendElem        *pendElem;      <span class=comment>// ptr to Task, Semaphore, Event,</span>
  1870                                            <span class=comment>// or GateMutexPri PendElem</span>
  1871            SizeT           stackSize;      <span class=comment>// Task's stack buffer size</span>
  1872            Char            stack[];        <span class=comment>// buffer used for Task's stack</span>
  1873            IHeap.Handle    stackHeap;      <span class=comment>// Heap to allocate stack from</span>
  1874            FuncPtr         fxn;            <span class=comment>// Task function</span>
  1875            UArg            arg0;           <span class=comment>// Task function 1st arg</span>
  1876            UArg            arg1;           <span class=comment>// Task function 2nd arg</span>
  1877            Ptr             env;            <span class=comment>// Task environment pointer</span>
  1878            Ptr             hookEnv[];      <span class=comment>// ptr to Task's hook env array</span>
  1879            Bool            vitalTaskFlag;  <span class=comment>// TRUE = shutdown system if</span>
  1880                                            <span class=comment>// last task like this exits</span>
  1881            Queue.Handle    readyQ;         <span class=comment>// This Task's readyQ</span>
  1882            UInt            curCoreId;      <span class=comment>// Core this task is currently running on.</span>
  1883            UInt            affinity;       <span class=comment>// Core this task must run on</span>
  1884                                            <span class=comment>// Task_AFFINITY_NONE = don't care</span>
  1885        };
  1886    
  1887        <span class=key>struct</span> Module_State {
  1888            volatile Bool   locked;         <span class=comment>// Task scheduler locked flag</span>
  1889            volatile UInt   curSet;         <span class=comment>// Bitmask reflects readyQ states</span>
  1890            Bool            workFlag;       <span class=comment>// Scheduler work is pending.</span>
  1891                                            <span class=comment>// Optimization. Must be set</span>
  1892                                            <span class=comment>// whenever readyQs are modified.</span>
  1893            UInt            vitalTasks;     <span class=comment>// number of tasks with</span>
  1894                                            <span class=comment>// vitalTaskFlag = true</span>
  1895            Handle          curTask;        <span class=comment>// current Task instance</span>
  1896            Queue.Handle    curQ;           <span class=comment>// current Task's readyQ</span>
  1897            Queue.Object    readyQ[];       <span class=comment>// Task ready queues</span>
  1898    
  1899            volatile UInt   smpCurSet[];    <span class=comment>// Bitmask reflects readyQ states</span>
  1900                                            <span class=comment>// curSet[n] = core n</span>
  1901                                            <span class=comment>// curSet[Core.numCores] = don't care</span>
  1902            volatile UInt   smpCurMask[];   <span class=comment>// mask of currently running tasks</span>
  1903            Handle          smpCurTask[];   <span class=comment>// current Task instance ([0] = core 0, etc)</span>
  1904            Queue.Handle    smpReadyQ[];    <span class=comment>// core ready queues</span>
  1905                                            <span class=comment>// [0] = core0 readyQs</span>
  1906                                            <span class=comment>// [1] = core1 readyQs</span>
  1907                                            <span class=comment>// [numCores] = don't care readyQs</span>
  1908            Queue.Object    inactiveQ;      <span class=comment>// Task's with -1 priority</span>
  1909            Queue.Object    terminatedQ;    <span class=comment>// terminated dynamically created Tasks</span>
  1910    
  1911            Handle          idleTask[];             <span class=comment>// Idle Task handles</span>
  1912            Handle          constructedTasks[];     <span class=comment>// array of statically</span>
  1913                                                    <span class=comment>// constructed Tasks</span>
  1914        };
  1915    
  1916        <span class=key>struct</span> RunQEntry {
  1917            Queue.Elem      elem;
  1918            UInt            coreId;
  1919            Int             priority;
  1920        };
  1921    
  1922        <span class=key>struct</span> Module_StateSmp {
  1923            Queue.Object            *sortedRunQ;     <span class=comment>// A queue of RunQEntry elems</span>
  1924                                                     <span class=comment>// that is  sorted by priority</span>
  1925            volatile RunQEntry       smpRunQ[];      <span class=comment>// Run queue entry handles for</span>
  1926                                                     <span class=comment>// each core</span>
  1927        };
  1928    }
</pre>
</body></html>
